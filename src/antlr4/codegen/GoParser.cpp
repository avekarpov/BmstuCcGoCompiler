#include "GoParserBase.h"

// Generated from /Users/artem.karpov/University/Sem2/Cc/CourseWork/GoCompiler/grammar/GoParser.g4 by ANTLR 4.13.1


#include "GoParserVisitor.h"

#include "GoParser.h"


using namespace antlrcpp;

using namespace antlr4;

namespace {

struct GoParserStaticData final {
  GoParserStaticData(std::vector<std::string> ruleNames,
                        std::vector<std::string> literalNames,
                        std::vector<std::string> symbolicNames)
      : ruleNames(std::move(ruleNames)), literalNames(std::move(literalNames)),
        symbolicNames(std::move(symbolicNames)),
        vocabulary(this->literalNames, this->symbolicNames) {}

  GoParserStaticData(const GoParserStaticData&) = delete;
  GoParserStaticData(GoParserStaticData&&) = delete;
  GoParserStaticData& operator=(const GoParserStaticData&) = delete;
  GoParserStaticData& operator=(GoParserStaticData&&) = delete;

  std::vector<antlr4::dfa::DFA> decisionToDFA;
  antlr4::atn::PredictionContextCache sharedContextCache;
  const std::vector<std::string> ruleNames;
  const std::vector<std::string> literalNames;
  const std::vector<std::string> symbolicNames;
  const antlr4::dfa::Vocabulary vocabulary;
  antlr4::atn::SerializedATNView serializedATN;
  std::unique_ptr<antlr4::atn::ATN> atn;
};

::antlr4::internal::OnceFlag goparserParserOnceFlag;
#if ANTLR4_USE_THREAD_LOCAL_CACHE
static thread_local
#endif
GoParserStaticData *goparserParserStaticData = nullptr;

void goparserParserInitialize() {
#if ANTLR4_USE_THREAD_LOCAL_CACHE
  if (goparserParserStaticData != nullptr) {
    return;
  }
#else
  assert(goparserParserStaticData == nullptr);
#endif
  auto staticData = std::make_unique<GoParserStaticData>(
    std::vector<std::string>{
      "sourceFile", "packageClause", "importDecl", "importSpec", "importPath", 
      "declaration", "constDecl", "constSpec", "identifierList", "expressionList", 
      "typeDecl", "typeSpec", "aliasDecl", "typeDef", "typeParameters", 
      "typeParameterDecl", "typeElement", "typeTerm", "functionDecl", "methodDecl", 
      "receiver", "varDecl", "varSpec", "block", "statementList", "statement", 
      "simpleStmt", "expressionStmt", "sendStmt", "incDecStmt", "assignment", 
      "assign_op", "shortVarDecl", "labeledStmt", "returnStmt", "breakStmt", 
      "continueStmt", "gotoStmt", "fallthroughStmt", "deferStmt", "ifStmt", 
      "switchStmt", "exprSwitchStmt", "exprCaseClause", "exprSwitchCase", 
      "typeSwitchStmt", "typeSwitchGuard", "typeCaseClause", "typeSwitchCase", 
      "typeList", "selectStmt", "commClause", "commCase", "recvStmt", "forStmt", 
      "forClause", "rangeClause", "goStmt", "type_", "typeArgs", "typeName", 
      "typeLit", "arrayType", "arrayLength", "elementType", "pointerType", 
      "interfaceType", "sliceType", "mapType", "channelType", "methodSpec", 
      "functionType", "signature", "result", "parameters", "parameterDecl", 
      "expression", "primaryExpr", "conversion", "operand", "literal", "basicLit", 
      "integer", "operandName", "qualifiedIdent", "compositeLit", "literalType", 
      "literalValue", "elementList", "keyedElement", "key", "element", "structType", 
      "fieldDecl", "string_", "embeddedField", "functionLit", "index", "slice_", 
      "typeAssertion", "arguments", "methodExpr", "eos"
    },
    std::vector<std::string>{
      "", "'break'", "'default'", "'func'", "'interface'", "'select'", "'case'", 
      "'defer'", "'go'", "'map'", "'struct'", "'chan'", "'else'", "'goto'", 
      "'package'", "'switch'", "'const'", "'fallthrough'", "'if'", "'range'", 
      "'type'", "'continue'", "'for'", "'import'", "'return'", "'var'", 
      "'nil'", "", "'('", "')'", "'{'", "'}'", "'['", "']'", "'='", "','", 
      "';'", "':'", "'.'", "'++'", "'--'", "':='", "'...'", "'||'", "'&&'", 
      "'=='", "'!='", "'<'", "'<='", "'>'", "'>='", "'|'", "'/'", "'%'", 
      "'<<'", "'>>'", "'&^'", "'~'", "'!'", "'+'", "'-'", "'^'", "'*'", 
      "'&'", "'<-'"
    },
    std::vector<std::string>{
      "", "BREAK", "DEFAULT", "FUNC", "INTERFACE", "SELECT", "CASE", "DEFER", 
      "GO", "MAP", "STRUCT", "CHAN", "ELSE", "GOTO", "PACKAGE", "SWITCH", 
      "CONST", "FALLTHROUGH", "IF", "RANGE", "TYPE", "CONTINUE", "FOR", 
      "IMPORT", "RETURN", "VAR", "NIL_LIT", "IDENTIFIER", "L_PAREN", "R_PAREN", 
      "L_CURLY", "R_CURLY", "L_BRACKET", "R_BRACKET", "ASSIGN", "COMMA", 
      "SEMI", "COLON", "DOT", "PLUS_PLUS", "MINUS_MINUS", "DECLARE_ASSIGN", 
      "ELLIPSIS", "LOGICAL_OR", "LOGICAL_AND", "EQUALS", "NOT_EQUALS", "LESS", 
      "LESS_OR_EQUALS", "GREATER", "GREATER_OR_EQUALS", "OR", "DIV", "MOD", 
      "LSHIFT", "RSHIFT", "BIT_CLEAR", "UNDERLYING", "EXCLAMATION", "PLUS", 
      "MINUS", "CARET", "STAR", "AMPERSAND", "RECEIVE", "DECIMAL_LIT", "BINARY_LIT", 
      "OCTAL_LIT", "HEX_LIT", "FLOAT_LIT", "DECIMAL_FLOAT_LIT", "HEX_FLOAT_LIT", 
      "IMAGINARY_LIT", "RUNE_LIT", "BYTE_VALUE", "OCTAL_BYTE_VALUE", "HEX_BYTE_VALUE", 
      "LITTLE_U_VALUE", "BIG_U_VALUE", "RAW_STRING_LIT", "INTERPRETED_STRING_LIT", 
      "WS", "COMMENT", "TERMINATOR", "LINE_COMMENT", "WS_NLSEMI", "COMMENT_NLSEMI", 
      "LINE_COMMENT_NLSEMI", "EOS", "OTHER"
    }
  );
  static const int32_t serializedATNSegment[] = {
  	4,1,89,1013,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,2,
  	7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,7,
  	14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,7,
  	21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,7,
  	28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,7,
  	35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,2,40,7,40,2,41,7,41,2,42,7,
  	42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,7,46,2,47,7,47,2,48,7,48,2,49,7,
  	49,2,50,7,50,2,51,7,51,2,52,7,52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,7,
  	56,2,57,7,57,2,58,7,58,2,59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,7,
  	63,2,64,7,64,2,65,7,65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,7,
  	70,2,71,7,71,2,72,7,72,2,73,7,73,2,74,7,74,2,75,7,75,2,76,7,76,2,77,7,
  	77,2,78,7,78,2,79,7,79,2,80,7,80,2,81,7,81,2,82,7,82,2,83,7,83,2,84,7,
  	84,2,85,7,85,2,86,7,86,2,87,7,87,2,88,7,88,2,89,7,89,2,90,7,90,2,91,7,
  	91,2,92,7,92,2,93,7,93,2,94,7,94,2,95,7,95,2,96,7,96,2,97,7,97,2,98,7,
  	98,2,99,7,99,2,100,7,100,2,101,7,101,2,102,7,102,1,0,1,0,1,0,1,0,1,0,
  	5,0,212,8,0,10,0,12,0,215,9,0,1,0,1,0,1,0,3,0,220,8,0,1,0,1,0,5,0,224,
  	8,0,10,0,12,0,227,9,0,1,0,1,0,1,1,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,5,2,
  	240,8,2,10,2,12,2,243,9,2,1,2,3,2,246,8,2,1,3,3,3,249,8,3,1,3,1,3,1,4,
  	1,4,1,5,1,5,1,5,3,5,258,8,5,1,6,1,6,1,6,1,6,1,6,1,6,5,6,266,8,6,10,6,
  	12,6,269,9,6,1,6,3,6,272,8,6,1,7,1,7,3,7,276,8,7,1,7,1,7,3,7,280,8,7,
  	1,8,1,8,1,8,5,8,285,8,8,10,8,12,8,288,9,8,1,9,1,9,1,9,5,9,293,8,9,10,
  	9,12,9,296,9,9,1,10,1,10,1,10,1,10,1,10,1,10,5,10,304,8,10,10,10,12,10,
  	307,9,10,1,10,3,10,310,8,10,1,11,1,11,3,11,314,8,11,1,12,1,12,1,12,1,
  	12,1,13,1,13,3,13,322,8,13,1,13,1,13,1,14,1,14,1,14,1,14,5,14,330,8,14,
  	10,14,12,14,333,9,14,1,14,1,14,1,15,1,15,1,15,1,16,1,16,1,16,5,16,343,
  	8,16,10,16,12,16,346,9,16,1,17,3,17,349,8,17,1,17,1,17,1,18,1,18,1,18,
  	3,18,356,8,18,1,18,1,18,3,18,360,8,18,1,19,1,19,1,19,1,19,1,19,3,19,367,
  	8,19,1,20,1,20,1,21,1,21,1,21,1,21,1,21,1,21,5,21,377,8,21,10,21,12,21,
  	380,9,21,1,21,3,21,383,8,21,1,22,1,22,1,22,1,22,3,22,389,8,22,1,22,1,
  	22,3,22,393,8,22,1,23,1,23,3,23,397,8,23,1,23,1,23,1,24,3,24,402,8,24,
  	1,24,3,24,405,8,24,1,24,3,24,408,8,24,1,24,1,24,1,24,4,24,413,8,24,11,
  	24,12,24,414,1,25,1,25,1,25,1,25,1,25,1,25,1,25,1,25,1,25,1,25,1,25,1,
  	25,1,25,1,25,1,25,3,25,432,8,25,1,26,1,26,1,26,1,26,1,26,3,26,439,8,26,
  	1,27,1,27,1,28,1,28,1,28,1,28,1,29,1,29,1,29,1,30,1,30,1,30,1,30,1,31,
  	3,31,455,8,31,1,31,1,31,1,32,1,32,1,32,1,32,1,33,1,33,1,33,3,33,466,8,
  	33,1,34,1,34,3,34,470,8,34,1,35,1,35,3,35,474,8,35,1,36,1,36,3,36,478,
  	8,36,1,37,1,37,1,37,1,38,1,38,1,39,1,39,1,39,1,40,1,40,1,40,1,40,1,40,
  	1,40,1,40,1,40,1,40,3,40,497,8,40,1,40,1,40,1,40,1,40,3,40,503,8,40,3,
  	40,505,8,40,1,41,1,41,3,41,509,8,41,1,42,1,42,3,42,513,8,42,1,42,3,42,
  	516,8,42,1,42,1,42,3,42,520,8,42,3,42,522,8,42,1,42,1,42,5,42,526,8,42,
  	10,42,12,42,529,9,42,1,42,1,42,1,43,1,43,1,43,3,43,536,8,43,1,44,1,44,
  	1,44,3,44,541,8,44,1,45,1,45,1,45,1,45,1,45,1,45,1,45,1,45,1,45,3,45,
  	552,8,45,1,45,1,45,5,45,556,8,45,10,45,12,45,559,9,45,1,45,1,45,1,46,
  	1,46,3,46,565,8,46,1,46,1,46,1,46,1,46,1,46,1,46,1,47,1,47,1,47,3,47,
  	576,8,47,1,48,1,48,1,48,3,48,581,8,48,1,49,1,49,3,49,585,8,49,1,49,1,
  	49,1,49,3,49,590,8,49,5,49,592,8,49,10,49,12,49,595,9,49,1,50,1,50,1,
  	50,5,50,600,8,50,10,50,12,50,603,9,50,1,50,1,50,1,51,1,51,1,51,3,51,610,
  	8,51,1,52,1,52,1,52,3,52,615,8,52,1,52,3,52,618,8,52,1,53,1,53,1,53,1,
  	53,1,53,1,53,3,53,626,8,53,1,53,1,53,1,54,1,54,3,54,632,8,54,1,54,1,54,
  	3,54,636,8,54,3,54,638,8,54,1,54,1,54,1,55,3,55,643,8,55,1,55,1,55,3,
  	55,647,8,55,1,55,1,55,3,55,651,8,55,1,56,1,56,1,56,1,56,1,56,1,56,3,56,
  	659,8,56,1,56,1,56,1,56,1,57,1,57,1,57,1,58,1,58,3,58,669,8,58,1,58,1,
  	58,1,58,1,58,1,58,3,58,676,8,58,1,59,1,59,1,59,3,59,681,8,59,1,59,1,59,
  	1,60,1,60,3,60,687,8,60,1,61,1,61,1,61,1,61,1,61,1,61,1,61,1,61,3,61,
  	697,8,61,1,62,1,62,1,62,1,62,1,62,1,63,1,63,1,64,1,64,1,65,1,65,1,65,
  	1,66,1,66,1,66,1,66,3,66,715,8,66,1,66,1,66,5,66,719,8,66,10,66,12,66,
  	722,9,66,1,66,1,66,1,67,1,67,1,67,1,67,1,68,1,68,1,68,1,68,1,68,1,68,
  	1,69,1,69,1,69,1,69,1,69,3,69,741,8,69,1,69,1,69,1,70,1,70,1,70,1,70,
  	1,70,1,70,3,70,751,8,70,1,71,1,71,1,71,1,72,1,72,3,72,758,8,72,1,73,1,
  	73,3,73,762,8,73,1,74,1,74,1,74,1,74,5,74,768,8,74,10,74,12,74,771,9,
  	74,1,74,3,74,774,8,74,3,74,776,8,74,1,74,1,74,1,75,3,75,781,8,75,1,75,
  	3,75,784,8,75,1,75,1,75,1,76,1,76,1,76,1,76,3,76,792,8,76,1,76,1,76,1,
  	76,1,76,1,76,1,76,1,76,1,76,1,76,1,76,1,76,1,76,1,76,1,76,1,76,5,76,809,
  	8,76,10,76,12,76,812,9,76,1,77,1,77,1,77,1,77,3,77,818,8,77,1,77,1,77,
  	1,77,1,77,1,77,1,77,1,77,3,77,827,8,77,5,77,829,8,77,10,77,12,77,832,
  	9,77,1,78,1,78,1,78,1,78,3,78,838,8,78,1,78,1,78,1,79,1,79,1,79,3,79,
  	845,8,79,1,79,1,79,1,79,1,79,3,79,851,8,79,1,80,1,80,1,80,3,80,856,8,
  	80,1,81,1,81,1,81,1,81,3,81,862,8,81,1,82,1,82,1,83,1,83,1,84,1,84,1,
  	84,1,84,1,85,1,85,1,85,1,86,1,86,1,86,1,86,1,86,1,86,1,86,1,86,1,86,1,
  	86,3,86,885,8,86,3,86,887,8,86,1,87,1,87,1,87,3,87,892,8,87,3,87,894,
  	8,87,1,87,1,87,1,88,1,88,1,88,5,88,901,8,88,10,88,12,88,904,9,88,1,89,
  	1,89,1,89,3,89,909,8,89,1,89,1,89,1,90,1,90,3,90,915,8,90,1,91,1,91,3,
  	91,919,8,91,1,92,1,92,1,92,1,92,1,92,5,92,926,8,92,10,92,12,92,929,9,
  	92,1,92,1,92,1,93,1,93,1,93,1,93,3,93,937,8,93,1,93,3,93,940,8,93,1,94,
  	1,94,1,95,3,95,945,8,95,1,95,1,95,3,95,949,8,95,1,96,1,96,1,96,1,96,1,
  	97,1,97,1,97,1,97,1,98,1,98,3,98,961,8,98,1,98,1,98,3,98,965,8,98,1,98,
  	3,98,968,8,98,1,98,1,98,1,98,1,98,1,98,3,98,975,8,98,1,98,1,98,1,99,1,
  	99,1,99,1,99,1,99,1,100,1,100,1,100,1,100,1,100,3,100,989,8,100,3,100,
  	991,8,100,1,100,3,100,994,8,100,1,100,3,100,997,8,100,3,100,999,8,100,
  	1,100,1,100,1,101,1,101,1,101,1,101,1,102,1,102,1,102,1,102,3,102,1011,
  	8,102,1,102,0,2,152,154,103,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,
  	32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,
  	78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,112,114,116,
  	118,120,122,124,126,128,130,132,134,136,138,140,142,144,146,148,150,152,
  	154,156,158,160,162,164,166,168,170,172,174,176,178,180,182,184,186,188,
  	190,192,194,196,198,200,202,204,0,9,2,0,27,27,38,38,1,0,39,40,2,0,51,
  	56,59,63,1,0,58,64,2,0,52,56,62,63,2,0,51,51,59,61,1,0,45,50,2,0,65,68,
  	72,73,1,0,79,80,1078,0,206,1,0,0,0,2,230,1,0,0,0,4,233,1,0,0,0,6,248,
  	1,0,0,0,8,252,1,0,0,0,10,257,1,0,0,0,12,259,1,0,0,0,14,273,1,0,0,0,16,
  	281,1,0,0,0,18,289,1,0,0,0,20,297,1,0,0,0,22,313,1,0,0,0,24,315,1,0,0,
  	0,26,319,1,0,0,0,28,325,1,0,0,0,30,336,1,0,0,0,32,339,1,0,0,0,34,348,
  	1,0,0,0,36,352,1,0,0,0,38,361,1,0,0,0,40,368,1,0,0,0,42,370,1,0,0,0,44,
  	384,1,0,0,0,46,394,1,0,0,0,48,412,1,0,0,0,50,431,1,0,0,0,52,438,1,0,0,
  	0,54,440,1,0,0,0,56,442,1,0,0,0,58,446,1,0,0,0,60,449,1,0,0,0,62,454,
  	1,0,0,0,64,458,1,0,0,0,66,462,1,0,0,0,68,467,1,0,0,0,70,471,1,0,0,0,72,
  	475,1,0,0,0,74,479,1,0,0,0,76,482,1,0,0,0,78,484,1,0,0,0,80,487,1,0,0,
  	0,82,508,1,0,0,0,84,510,1,0,0,0,86,532,1,0,0,0,88,540,1,0,0,0,90,542,
  	1,0,0,0,92,564,1,0,0,0,94,572,1,0,0,0,96,580,1,0,0,0,98,584,1,0,0,0,100,
  	596,1,0,0,0,102,606,1,0,0,0,104,617,1,0,0,0,106,625,1,0,0,0,108,629,1,
  	0,0,0,110,642,1,0,0,0,112,658,1,0,0,0,114,663,1,0,0,0,116,675,1,0,0,0,
  	118,677,1,0,0,0,120,686,1,0,0,0,122,696,1,0,0,0,124,698,1,0,0,0,126,703,
  	1,0,0,0,128,705,1,0,0,0,130,707,1,0,0,0,132,710,1,0,0,0,134,725,1,0,0,
  	0,136,729,1,0,0,0,138,740,1,0,0,0,140,750,1,0,0,0,142,752,1,0,0,0,144,
  	755,1,0,0,0,146,761,1,0,0,0,148,763,1,0,0,0,150,780,1,0,0,0,152,791,1,
  	0,0,0,154,817,1,0,0,0,156,833,1,0,0,0,158,850,1,0,0,0,160,855,1,0,0,0,
  	162,861,1,0,0,0,164,863,1,0,0,0,166,865,1,0,0,0,168,867,1,0,0,0,170,871,
  	1,0,0,0,172,886,1,0,0,0,174,888,1,0,0,0,176,897,1,0,0,0,178,908,1,0,0,
  	0,180,914,1,0,0,0,182,918,1,0,0,0,184,920,1,0,0,0,186,936,1,0,0,0,188,
  	941,1,0,0,0,190,944,1,0,0,0,192,950,1,0,0,0,194,954,1,0,0,0,196,958,1,
  	0,0,0,198,978,1,0,0,0,200,983,1,0,0,0,202,1002,1,0,0,0,204,1010,1,0,0,
  	0,206,207,3,2,1,0,207,213,3,204,102,0,208,209,3,4,2,0,209,210,3,204,102,
  	0,210,212,1,0,0,0,211,208,1,0,0,0,212,215,1,0,0,0,213,211,1,0,0,0,213,
  	214,1,0,0,0,214,225,1,0,0,0,215,213,1,0,0,0,216,220,3,36,18,0,217,220,
  	3,38,19,0,218,220,3,10,5,0,219,216,1,0,0,0,219,217,1,0,0,0,219,218,1,
  	0,0,0,220,221,1,0,0,0,221,222,3,204,102,0,222,224,1,0,0,0,223,219,1,0,
  	0,0,224,227,1,0,0,0,225,223,1,0,0,0,225,226,1,0,0,0,226,228,1,0,0,0,227,
  	225,1,0,0,0,228,229,5,0,0,1,229,1,1,0,0,0,230,231,5,14,0,0,231,232,5,
  	27,0,0,232,3,1,0,0,0,233,245,5,23,0,0,234,246,3,6,3,0,235,241,5,28,0,
  	0,236,237,3,6,3,0,237,238,3,204,102,0,238,240,1,0,0,0,239,236,1,0,0,0,
  	240,243,1,0,0,0,241,239,1,0,0,0,241,242,1,0,0,0,242,244,1,0,0,0,243,241,
  	1,0,0,0,244,246,5,29,0,0,245,234,1,0,0,0,245,235,1,0,0,0,246,5,1,0,0,
  	0,247,249,7,0,0,0,248,247,1,0,0,0,248,249,1,0,0,0,249,250,1,0,0,0,250,
  	251,3,8,4,0,251,7,1,0,0,0,252,253,3,188,94,0,253,9,1,0,0,0,254,258,3,
  	12,6,0,255,258,3,20,10,0,256,258,3,42,21,0,257,254,1,0,0,0,257,255,1,
  	0,0,0,257,256,1,0,0,0,258,11,1,0,0,0,259,271,5,16,0,0,260,272,3,14,7,
  	0,261,267,5,28,0,0,262,263,3,14,7,0,263,264,3,204,102,0,264,266,1,0,0,
  	0,265,262,1,0,0,0,266,269,1,0,0,0,267,265,1,0,0,0,267,268,1,0,0,0,268,
  	270,1,0,0,0,269,267,1,0,0,0,270,272,5,29,0,0,271,260,1,0,0,0,271,261,
  	1,0,0,0,272,13,1,0,0,0,273,279,3,16,8,0,274,276,3,116,58,0,275,274,1,
  	0,0,0,275,276,1,0,0,0,276,277,1,0,0,0,277,278,5,34,0,0,278,280,3,18,9,
  	0,279,275,1,0,0,0,279,280,1,0,0,0,280,15,1,0,0,0,281,286,5,27,0,0,282,
  	283,5,35,0,0,283,285,5,27,0,0,284,282,1,0,0,0,285,288,1,0,0,0,286,284,
  	1,0,0,0,286,287,1,0,0,0,287,17,1,0,0,0,288,286,1,0,0,0,289,294,3,152,
  	76,0,290,291,5,35,0,0,291,293,3,152,76,0,292,290,1,0,0,0,293,296,1,0,
  	0,0,294,292,1,0,0,0,294,295,1,0,0,0,295,19,1,0,0,0,296,294,1,0,0,0,297,
  	309,5,20,0,0,298,310,3,22,11,0,299,305,5,28,0,0,300,301,3,22,11,0,301,
  	302,3,204,102,0,302,304,1,0,0,0,303,300,1,0,0,0,304,307,1,0,0,0,305,303,
  	1,0,0,0,305,306,1,0,0,0,306,308,1,0,0,0,307,305,1,0,0,0,308,310,5,29,
  	0,0,309,298,1,0,0,0,309,299,1,0,0,0,310,21,1,0,0,0,311,314,3,24,12,0,
  	312,314,3,26,13,0,313,311,1,0,0,0,313,312,1,0,0,0,314,23,1,0,0,0,315,
  	316,5,27,0,0,316,317,5,34,0,0,317,318,3,116,58,0,318,25,1,0,0,0,319,321,
  	5,27,0,0,320,322,3,28,14,0,321,320,1,0,0,0,321,322,1,0,0,0,322,323,1,
  	0,0,0,323,324,3,116,58,0,324,27,1,0,0,0,325,326,5,32,0,0,326,331,3,30,
  	15,0,327,328,5,35,0,0,328,330,3,30,15,0,329,327,1,0,0,0,330,333,1,0,0,
  	0,331,329,1,0,0,0,331,332,1,0,0,0,332,334,1,0,0,0,333,331,1,0,0,0,334,
  	335,5,33,0,0,335,29,1,0,0,0,336,337,3,16,8,0,337,338,3,32,16,0,338,31,
  	1,0,0,0,339,344,3,34,17,0,340,341,5,51,0,0,341,343,3,34,17,0,342,340,
  	1,0,0,0,343,346,1,0,0,0,344,342,1,0,0,0,344,345,1,0,0,0,345,33,1,0,0,
  	0,346,344,1,0,0,0,347,349,5,57,0,0,348,347,1,0,0,0,348,349,1,0,0,0,349,
  	350,1,0,0,0,350,351,3,116,58,0,351,35,1,0,0,0,352,353,5,3,0,0,353,355,
  	5,27,0,0,354,356,3,28,14,0,355,354,1,0,0,0,355,356,1,0,0,0,356,357,1,
  	0,0,0,357,359,3,144,72,0,358,360,3,46,23,0,359,358,1,0,0,0,359,360,1,
  	0,0,0,360,37,1,0,0,0,361,362,5,3,0,0,362,363,3,40,20,0,363,364,5,27,0,
  	0,364,366,3,144,72,0,365,367,3,46,23,0,366,365,1,0,0,0,366,367,1,0,0,
  	0,367,39,1,0,0,0,368,369,3,148,74,0,369,41,1,0,0,0,370,382,5,25,0,0,371,
  	383,3,44,22,0,372,378,5,28,0,0,373,374,3,44,22,0,374,375,3,204,102,0,
  	375,377,1,0,0,0,376,373,1,0,0,0,377,380,1,0,0,0,378,376,1,0,0,0,378,379,
  	1,0,0,0,379,381,1,0,0,0,380,378,1,0,0,0,381,383,5,29,0,0,382,371,1,0,
  	0,0,382,372,1,0,0,0,383,43,1,0,0,0,384,392,3,16,8,0,385,388,3,116,58,
  	0,386,387,5,34,0,0,387,389,3,18,9,0,388,386,1,0,0,0,388,389,1,0,0,0,389,
  	393,1,0,0,0,390,391,5,34,0,0,391,393,3,18,9,0,392,385,1,0,0,0,392,390,
  	1,0,0,0,393,45,1,0,0,0,394,396,5,30,0,0,395,397,3,48,24,0,396,395,1,0,
  	0,0,396,397,1,0,0,0,397,398,1,0,0,0,398,399,5,31,0,0,399,47,1,0,0,0,400,
  	402,5,36,0,0,401,400,1,0,0,0,401,402,1,0,0,0,402,408,1,0,0,0,403,405,
  	5,88,0,0,404,403,1,0,0,0,404,405,1,0,0,0,405,408,1,0,0,0,406,408,4,24,
  	0,0,407,401,1,0,0,0,407,404,1,0,0,0,407,406,1,0,0,0,408,409,1,0,0,0,409,
  	410,3,50,25,0,410,411,3,204,102,0,411,413,1,0,0,0,412,407,1,0,0,0,413,
  	414,1,0,0,0,414,412,1,0,0,0,414,415,1,0,0,0,415,49,1,0,0,0,416,432,3,
  	10,5,0,417,432,3,66,33,0,418,432,3,52,26,0,419,432,3,114,57,0,420,432,
  	3,68,34,0,421,432,3,70,35,0,422,432,3,72,36,0,423,432,3,74,37,0,424,432,
  	3,76,38,0,425,432,3,46,23,0,426,432,3,80,40,0,427,432,3,82,41,0,428,432,
  	3,100,50,0,429,432,3,108,54,0,430,432,3,78,39,0,431,416,1,0,0,0,431,417,
  	1,0,0,0,431,418,1,0,0,0,431,419,1,0,0,0,431,420,1,0,0,0,431,421,1,0,0,
  	0,431,422,1,0,0,0,431,423,1,0,0,0,431,424,1,0,0,0,431,425,1,0,0,0,431,
  	426,1,0,0,0,431,427,1,0,0,0,431,428,1,0,0,0,431,429,1,0,0,0,431,430,1,
  	0,0,0,432,51,1,0,0,0,433,439,3,56,28,0,434,439,3,58,29,0,435,439,3,60,
  	30,0,436,439,3,54,27,0,437,439,3,64,32,0,438,433,1,0,0,0,438,434,1,0,
  	0,0,438,435,1,0,0,0,438,436,1,0,0,0,438,437,1,0,0,0,439,53,1,0,0,0,440,
  	441,3,152,76,0,441,55,1,0,0,0,442,443,3,152,76,0,443,444,5,64,0,0,444,
  	445,3,152,76,0,445,57,1,0,0,0,446,447,3,152,76,0,447,448,7,1,0,0,448,
  	59,1,0,0,0,449,450,3,18,9,0,450,451,3,62,31,0,451,452,3,18,9,0,452,61,
  	1,0,0,0,453,455,7,2,0,0,454,453,1,0,0,0,454,455,1,0,0,0,455,456,1,0,0,
  	0,456,457,5,34,0,0,457,63,1,0,0,0,458,459,3,16,8,0,459,460,5,41,0,0,460,
  	461,3,18,9,0,461,65,1,0,0,0,462,463,5,27,0,0,463,465,5,37,0,0,464,466,
  	3,50,25,0,465,464,1,0,0,0,465,466,1,0,0,0,466,67,1,0,0,0,467,469,5,24,
  	0,0,468,470,3,18,9,0,469,468,1,0,0,0,469,470,1,0,0,0,470,69,1,0,0,0,471,
  	473,5,1,0,0,472,474,5,27,0,0,473,472,1,0,0,0,473,474,1,0,0,0,474,71,1,
  	0,0,0,475,477,5,21,0,0,476,478,5,27,0,0,477,476,1,0,0,0,477,478,1,0,0,
  	0,478,73,1,0,0,0,479,480,5,13,0,0,480,481,5,27,0,0,481,75,1,0,0,0,482,
  	483,5,17,0,0,483,77,1,0,0,0,484,485,5,7,0,0,485,486,3,152,76,0,486,79,
  	1,0,0,0,487,496,5,18,0,0,488,497,3,152,76,0,489,490,3,204,102,0,490,491,
  	3,152,76,0,491,497,1,0,0,0,492,493,3,52,26,0,493,494,3,204,102,0,494,
  	495,3,152,76,0,495,497,1,0,0,0,496,488,1,0,0,0,496,489,1,0,0,0,496,492,
  	1,0,0,0,497,498,1,0,0,0,498,504,3,46,23,0,499,502,5,12,0,0,500,503,3,
  	80,40,0,501,503,3,46,23,0,502,500,1,0,0,0,502,501,1,0,0,0,503,505,1,0,
  	0,0,504,499,1,0,0,0,504,505,1,0,0,0,505,81,1,0,0,0,506,509,3,84,42,0,
  	507,509,3,90,45,0,508,506,1,0,0,0,508,507,1,0,0,0,509,83,1,0,0,0,510,
  	521,5,15,0,0,511,513,3,152,76,0,512,511,1,0,0,0,512,513,1,0,0,0,513,522,
  	1,0,0,0,514,516,3,52,26,0,515,514,1,0,0,0,515,516,1,0,0,0,516,517,1,0,
  	0,0,517,519,3,204,102,0,518,520,3,152,76,0,519,518,1,0,0,0,519,520,1,
  	0,0,0,520,522,1,0,0,0,521,512,1,0,0,0,521,515,1,0,0,0,522,523,1,0,0,0,
  	523,527,5,30,0,0,524,526,3,86,43,0,525,524,1,0,0,0,526,529,1,0,0,0,527,
  	525,1,0,0,0,527,528,1,0,0,0,528,530,1,0,0,0,529,527,1,0,0,0,530,531,5,
  	31,0,0,531,85,1,0,0,0,532,533,3,88,44,0,533,535,5,37,0,0,534,536,3,48,
  	24,0,535,534,1,0,0,0,535,536,1,0,0,0,536,87,1,0,0,0,537,538,5,6,0,0,538,
  	541,3,18,9,0,539,541,5,2,0,0,540,537,1,0,0,0,540,539,1,0,0,0,541,89,1,
  	0,0,0,542,551,5,15,0,0,543,552,3,92,46,0,544,545,3,204,102,0,545,546,
  	3,92,46,0,546,552,1,0,0,0,547,548,3,52,26,0,548,549,3,204,102,0,549,550,
  	3,92,46,0,550,552,1,0,0,0,551,543,1,0,0,0,551,544,1,0,0,0,551,547,1,0,
  	0,0,552,553,1,0,0,0,553,557,5,30,0,0,554,556,3,94,47,0,555,554,1,0,0,
  	0,556,559,1,0,0,0,557,555,1,0,0,0,557,558,1,0,0,0,558,560,1,0,0,0,559,
  	557,1,0,0,0,560,561,5,31,0,0,561,91,1,0,0,0,562,563,5,27,0,0,563,565,
  	5,41,0,0,564,562,1,0,0,0,564,565,1,0,0,0,565,566,1,0,0,0,566,567,3,154,
  	77,0,567,568,5,38,0,0,568,569,5,28,0,0,569,570,5,20,0,0,570,571,5,29,
  	0,0,571,93,1,0,0,0,572,573,3,96,48,0,573,575,5,37,0,0,574,576,3,48,24,
  	0,575,574,1,0,0,0,575,576,1,0,0,0,576,95,1,0,0,0,577,578,5,6,0,0,578,
  	581,3,98,49,0,579,581,5,2,0,0,580,577,1,0,0,0,580,579,1,0,0,0,581,97,
  	1,0,0,0,582,585,3,116,58,0,583,585,5,26,0,0,584,582,1,0,0,0,584,583,1,
  	0,0,0,585,593,1,0,0,0,586,589,5,35,0,0,587,590,3,116,58,0,588,590,5,26,
  	0,0,589,587,1,0,0,0,589,588,1,0,0,0,590,592,1,0,0,0,591,586,1,0,0,0,592,
  	595,1,0,0,0,593,591,1,0,0,0,593,594,1,0,0,0,594,99,1,0,0,0,595,593,1,
  	0,0,0,596,597,5,5,0,0,597,601,5,30,0,0,598,600,3,102,51,0,599,598,1,0,
  	0,0,600,603,1,0,0,0,601,599,1,0,0,0,601,602,1,0,0,0,602,604,1,0,0,0,603,
  	601,1,0,0,0,604,605,5,31,0,0,605,101,1,0,0,0,606,607,3,104,52,0,607,609,
  	5,37,0,0,608,610,3,48,24,0,609,608,1,0,0,0,609,610,1,0,0,0,610,103,1,
  	0,0,0,611,614,5,6,0,0,612,615,3,56,28,0,613,615,3,106,53,0,614,612,1,
  	0,0,0,614,613,1,0,0,0,615,618,1,0,0,0,616,618,5,2,0,0,617,611,1,0,0,0,
  	617,616,1,0,0,0,618,105,1,0,0,0,619,620,3,18,9,0,620,621,5,34,0,0,621,
  	626,1,0,0,0,622,623,3,16,8,0,623,624,5,41,0,0,624,626,1,0,0,0,625,619,
  	1,0,0,0,625,622,1,0,0,0,625,626,1,0,0,0,626,627,1,0,0,0,627,628,3,152,
  	76,0,628,107,1,0,0,0,629,637,5,22,0,0,630,632,3,152,76,0,631,630,1,0,
  	0,0,631,632,1,0,0,0,632,638,1,0,0,0,633,638,3,110,55,0,634,636,3,112,
  	56,0,635,634,1,0,0,0,635,636,1,0,0,0,636,638,1,0,0,0,637,631,1,0,0,0,
  	637,633,1,0,0,0,637,635,1,0,0,0,638,639,1,0,0,0,639,640,3,46,23,0,640,
  	109,1,0,0,0,641,643,3,52,26,0,642,641,1,0,0,0,642,643,1,0,0,0,643,644,
  	1,0,0,0,644,646,3,204,102,0,645,647,3,152,76,0,646,645,1,0,0,0,646,647,
  	1,0,0,0,647,648,1,0,0,0,648,650,3,204,102,0,649,651,3,52,26,0,650,649,
  	1,0,0,0,650,651,1,0,0,0,651,111,1,0,0,0,652,653,3,18,9,0,653,654,5,34,
  	0,0,654,659,1,0,0,0,655,656,3,16,8,0,656,657,5,41,0,0,657,659,1,0,0,0,
  	658,652,1,0,0,0,658,655,1,0,0,0,658,659,1,0,0,0,659,660,1,0,0,0,660,661,
  	5,19,0,0,661,662,3,152,76,0,662,113,1,0,0,0,663,664,5,8,0,0,664,665,3,
  	152,76,0,665,115,1,0,0,0,666,668,3,120,60,0,667,669,3,118,59,0,668,667,
  	1,0,0,0,668,669,1,0,0,0,669,676,1,0,0,0,670,676,3,122,61,0,671,672,5,
  	28,0,0,672,673,3,116,58,0,673,674,5,29,0,0,674,676,1,0,0,0,675,666,1,
  	0,0,0,675,670,1,0,0,0,675,671,1,0,0,0,676,117,1,0,0,0,677,678,5,32,0,
  	0,678,680,3,98,49,0,679,681,5,35,0,0,680,679,1,0,0,0,680,681,1,0,0,0,
  	681,682,1,0,0,0,682,683,5,33,0,0,683,119,1,0,0,0,684,687,3,168,84,0,685,
  	687,5,27,0,0,686,684,1,0,0,0,686,685,1,0,0,0,687,121,1,0,0,0,688,697,
  	3,124,62,0,689,697,3,184,92,0,690,697,3,130,65,0,691,697,3,142,71,0,692,
  	697,3,132,66,0,693,697,3,134,67,0,694,697,3,136,68,0,695,697,3,138,69,
  	0,696,688,1,0,0,0,696,689,1,0,0,0,696,690,1,0,0,0,696,691,1,0,0,0,696,
  	692,1,0,0,0,696,693,1,0,0,0,696,694,1,0,0,0,696,695,1,0,0,0,697,123,1,
  	0,0,0,698,699,5,32,0,0,699,700,3,126,63,0,700,701,5,33,0,0,701,702,3,
  	128,64,0,702,125,1,0,0,0,703,704,3,152,76,0,704,127,1,0,0,0,705,706,3,
  	116,58,0,706,129,1,0,0,0,707,708,5,62,0,0,708,709,3,116,58,0,709,131,
  	1,0,0,0,710,711,5,4,0,0,711,720,5,30,0,0,712,715,3,140,70,0,713,715,3,
  	32,16,0,714,712,1,0,0,0,714,713,1,0,0,0,715,716,1,0,0,0,716,717,3,204,
  	102,0,717,719,1,0,0,0,718,714,1,0,0,0,719,722,1,0,0,0,720,718,1,0,0,0,
  	720,721,1,0,0,0,721,723,1,0,0,0,722,720,1,0,0,0,723,724,5,31,0,0,724,
  	133,1,0,0,0,725,726,5,32,0,0,726,727,5,33,0,0,727,728,3,128,64,0,728,
  	135,1,0,0,0,729,730,5,9,0,0,730,731,5,32,0,0,731,732,3,116,58,0,732,733,
  	5,33,0,0,733,734,3,128,64,0,734,137,1,0,0,0,735,741,5,11,0,0,736,737,
  	5,11,0,0,737,741,5,64,0,0,738,739,5,64,0,0,739,741,5,11,0,0,740,735,1,
  	0,0,0,740,736,1,0,0,0,740,738,1,0,0,0,741,742,1,0,0,0,742,743,3,128,64,
  	0,743,139,1,0,0,0,744,745,5,27,0,0,745,746,3,148,74,0,746,747,3,146,73,
  	0,747,751,1,0,0,0,748,749,5,27,0,0,749,751,3,148,74,0,750,744,1,0,0,0,
  	750,748,1,0,0,0,751,141,1,0,0,0,752,753,5,3,0,0,753,754,3,144,72,0,754,
  	143,1,0,0,0,755,757,3,148,74,0,756,758,3,146,73,0,757,756,1,0,0,0,757,
  	758,1,0,0,0,758,145,1,0,0,0,759,762,3,148,74,0,760,762,3,116,58,0,761,
  	759,1,0,0,0,761,760,1,0,0,0,762,147,1,0,0,0,763,775,5,28,0,0,764,769,
  	3,150,75,0,765,766,5,35,0,0,766,768,3,150,75,0,767,765,1,0,0,0,768,771,
  	1,0,0,0,769,767,1,0,0,0,769,770,1,0,0,0,770,773,1,0,0,0,771,769,1,0,0,
  	0,772,774,5,35,0,0,773,772,1,0,0,0,773,774,1,0,0,0,774,776,1,0,0,0,775,
  	764,1,0,0,0,775,776,1,0,0,0,776,777,1,0,0,0,777,778,5,29,0,0,778,149,
  	1,0,0,0,779,781,3,16,8,0,780,779,1,0,0,0,780,781,1,0,0,0,781,783,1,0,
  	0,0,782,784,5,42,0,0,783,782,1,0,0,0,783,784,1,0,0,0,784,785,1,0,0,0,
  	785,786,3,116,58,0,786,151,1,0,0,0,787,788,6,76,-1,0,788,792,3,154,77,
  	0,789,790,7,3,0,0,790,792,3,152,76,6,791,787,1,0,0,0,791,789,1,0,0,0,
  	792,810,1,0,0,0,793,794,10,5,0,0,794,795,7,4,0,0,795,809,3,152,76,6,796,
  	797,10,4,0,0,797,798,7,5,0,0,798,809,3,152,76,5,799,800,10,3,0,0,800,
  	801,7,6,0,0,801,809,3,152,76,4,802,803,10,2,0,0,803,804,5,44,0,0,804,
  	809,3,152,76,3,805,806,10,1,0,0,806,807,5,43,0,0,807,809,3,152,76,2,808,
  	793,1,0,0,0,808,796,1,0,0,0,808,799,1,0,0,0,808,802,1,0,0,0,808,805,1,
  	0,0,0,809,812,1,0,0,0,810,808,1,0,0,0,810,811,1,0,0,0,811,153,1,0,0,0,
  	812,810,1,0,0,0,813,814,6,77,-1,0,814,818,3,158,79,0,815,818,3,156,78,
  	0,816,818,3,202,101,0,817,813,1,0,0,0,817,815,1,0,0,0,817,816,1,0,0,0,
  	818,830,1,0,0,0,819,826,10,1,0,0,820,821,5,38,0,0,821,827,5,27,0,0,822,
  	827,3,194,97,0,823,827,3,196,98,0,824,827,3,198,99,0,825,827,3,200,100,
  	0,826,820,1,0,0,0,826,822,1,0,0,0,826,823,1,0,0,0,826,824,1,0,0,0,826,
  	825,1,0,0,0,827,829,1,0,0,0,828,819,1,0,0,0,829,832,1,0,0,0,830,828,1,
  	0,0,0,830,831,1,0,0,0,831,155,1,0,0,0,832,830,1,0,0,0,833,834,3,116,58,
  	0,834,835,5,28,0,0,835,837,3,152,76,0,836,838,5,35,0,0,837,836,1,0,0,
  	0,837,838,1,0,0,0,838,839,1,0,0,0,839,840,5,29,0,0,840,157,1,0,0,0,841,
  	851,3,160,80,0,842,844,3,166,83,0,843,845,3,118,59,0,844,843,1,0,0,0,
  	844,845,1,0,0,0,845,851,1,0,0,0,846,847,5,28,0,0,847,848,3,152,76,0,848,
  	849,5,29,0,0,849,851,1,0,0,0,850,841,1,0,0,0,850,842,1,0,0,0,850,846,
  	1,0,0,0,851,159,1,0,0,0,852,856,3,162,81,0,853,856,3,170,85,0,854,856,
  	3,192,96,0,855,852,1,0,0,0,855,853,1,0,0,0,855,854,1,0,0,0,856,161,1,
  	0,0,0,857,862,5,26,0,0,858,862,3,164,82,0,859,862,3,188,94,0,860,862,
  	5,69,0,0,861,857,1,0,0,0,861,858,1,0,0,0,861,859,1,0,0,0,861,860,1,0,
  	0,0,862,163,1,0,0,0,863,864,7,7,0,0,864,165,1,0,0,0,865,866,5,27,0,0,
  	866,167,1,0,0,0,867,868,5,27,0,0,868,869,5,38,0,0,869,870,5,27,0,0,870,
  	169,1,0,0,0,871,872,3,172,86,0,872,873,3,174,87,0,873,171,1,0,0,0,874,
  	887,3,184,92,0,875,887,3,124,62,0,876,877,5,32,0,0,877,878,5,42,0,0,878,
  	879,5,33,0,0,879,887,3,128,64,0,880,887,3,134,67,0,881,887,3,136,68,0,
  	882,884,3,120,60,0,883,885,3,118,59,0,884,883,1,0,0,0,884,885,1,0,0,0,
  	885,887,1,0,0,0,886,874,1,0,0,0,886,875,1,0,0,0,886,876,1,0,0,0,886,880,
  	1,0,0,0,886,881,1,0,0,0,886,882,1,0,0,0,887,173,1,0,0,0,888,893,5,30,
  	0,0,889,891,3,176,88,0,890,892,5,35,0,0,891,890,1,0,0,0,891,892,1,0,0,
  	0,892,894,1,0,0,0,893,889,1,0,0,0,893,894,1,0,0,0,894,895,1,0,0,0,895,
  	896,5,31,0,0,896,175,1,0,0,0,897,902,3,178,89,0,898,899,5,35,0,0,899,
  	901,3,178,89,0,900,898,1,0,0,0,901,904,1,0,0,0,902,900,1,0,0,0,902,903,
  	1,0,0,0,903,177,1,0,0,0,904,902,1,0,0,0,905,906,3,180,90,0,906,907,5,
  	37,0,0,907,909,1,0,0,0,908,905,1,0,0,0,908,909,1,0,0,0,909,910,1,0,0,
  	0,910,911,3,182,91,0,911,179,1,0,0,0,912,915,3,152,76,0,913,915,3,174,
  	87,0,914,912,1,0,0,0,914,913,1,0,0,0,915,181,1,0,0,0,916,919,3,152,76,
  	0,917,919,3,174,87,0,918,916,1,0,0,0,918,917,1,0,0,0,919,183,1,0,0,0,
  	920,921,5,10,0,0,921,927,5,30,0,0,922,923,3,186,93,0,923,924,3,204,102,
  	0,924,926,1,0,0,0,925,922,1,0,0,0,926,929,1,0,0,0,927,925,1,0,0,0,927,
  	928,1,0,0,0,928,930,1,0,0,0,929,927,1,0,0,0,930,931,5,31,0,0,931,185,
  	1,0,0,0,932,933,3,16,8,0,933,934,3,116,58,0,934,937,1,0,0,0,935,937,3,
  	190,95,0,936,932,1,0,0,0,936,935,1,0,0,0,937,939,1,0,0,0,938,940,3,188,
  	94,0,939,938,1,0,0,0,939,940,1,0,0,0,940,187,1,0,0,0,941,942,7,8,0,0,
  	942,189,1,0,0,0,943,945,5,62,0,0,944,943,1,0,0,0,944,945,1,0,0,0,945,
  	946,1,0,0,0,946,948,3,120,60,0,947,949,3,118,59,0,948,947,1,0,0,0,948,
  	949,1,0,0,0,949,191,1,0,0,0,950,951,5,3,0,0,951,952,3,144,72,0,952,953,
  	3,46,23,0,953,193,1,0,0,0,954,955,5,32,0,0,955,956,3,152,76,0,956,957,
  	5,33,0,0,957,195,1,0,0,0,958,974,5,32,0,0,959,961,3,152,76,0,960,959,
  	1,0,0,0,960,961,1,0,0,0,961,962,1,0,0,0,962,964,5,37,0,0,963,965,3,152,
  	76,0,964,963,1,0,0,0,964,965,1,0,0,0,965,975,1,0,0,0,966,968,3,152,76,
  	0,967,966,1,0,0,0,967,968,1,0,0,0,968,969,1,0,0,0,969,970,5,37,0,0,970,
  	971,3,152,76,0,971,972,5,37,0,0,972,973,3,152,76,0,973,975,1,0,0,0,974,
  	960,1,0,0,0,974,967,1,0,0,0,975,976,1,0,0,0,976,977,5,33,0,0,977,197,
  	1,0,0,0,978,979,5,38,0,0,979,980,5,28,0,0,980,981,3,116,58,0,981,982,
  	5,29,0,0,982,199,1,0,0,0,983,998,5,28,0,0,984,991,3,18,9,0,985,988,3,
  	116,58,0,986,987,5,35,0,0,987,989,3,18,9,0,988,986,1,0,0,0,988,989,1,
  	0,0,0,989,991,1,0,0,0,990,984,1,0,0,0,990,985,1,0,0,0,991,993,1,0,0,0,
  	992,994,5,42,0,0,993,992,1,0,0,0,993,994,1,0,0,0,994,996,1,0,0,0,995,
  	997,5,35,0,0,996,995,1,0,0,0,996,997,1,0,0,0,997,999,1,0,0,0,998,990,
  	1,0,0,0,998,999,1,0,0,0,999,1000,1,0,0,0,1000,1001,5,29,0,0,1001,201,
  	1,0,0,0,1002,1003,3,116,58,0,1003,1004,5,38,0,0,1004,1005,5,27,0,0,1005,
  	203,1,0,0,0,1006,1011,5,36,0,0,1007,1011,5,0,0,1,1008,1011,5,88,0,0,1009,
  	1011,4,102,7,0,1010,1006,1,0,0,0,1010,1007,1,0,0,0,1010,1008,1,0,0,0,
  	1010,1009,1,0,0,0,1011,205,1,0,0,0,120,213,219,225,241,245,248,257,267,
  	271,275,279,286,294,305,309,313,321,331,344,348,355,359,366,378,382,388,
  	392,396,401,404,407,414,431,438,454,465,469,473,477,496,502,504,508,512,
  	515,519,521,527,535,540,551,557,564,575,580,584,589,593,601,609,614,617,
  	625,631,635,637,642,646,650,658,668,675,680,686,696,714,720,740,750,757,
  	761,769,773,775,780,783,791,808,810,817,826,830,837,844,850,855,861,884,
  	886,891,893,902,908,914,918,927,936,939,944,948,960,964,967,974,988,990,
  	993,996,998,1010
  };
  staticData->serializedATN = antlr4::atn::SerializedATNView(serializedATNSegment, sizeof(serializedATNSegment) / sizeof(serializedATNSegment[0]));

  antlr4::atn::ATNDeserializer deserializer;
  staticData->atn = deserializer.deserialize(staticData->serializedATN);

  const size_t count = staticData->atn->getNumberOfDecisions();
  staticData->decisionToDFA.reserve(count);
  for (size_t i = 0; i < count; i++) { 
    staticData->decisionToDFA.emplace_back(staticData->atn->getDecisionState(i), i);
  }
  goparserParserStaticData = staticData.release();
}

}

GoParser::GoParser(TokenStream *input) : GoParser(input, antlr4::atn::ParserATNSimulatorOptions()) {}

GoParser::GoParser(TokenStream *input, const antlr4::atn::ParserATNSimulatorOptions &options) : GoParserBase(input) {
  GoParser::initialize();
  _interpreter = new atn::ParserATNSimulator(this, *goparserParserStaticData->atn, goparserParserStaticData->decisionToDFA, goparserParserStaticData->sharedContextCache, options);
}

GoParser::~GoParser() {
  delete _interpreter;
}

const atn::ATN& GoParser::getATN() const {
  return *goparserParserStaticData->atn;
}

std::string GoParser::getGrammarFileName() const {
  return "GoParser.g4";
}

const std::vector<std::string>& GoParser::getRuleNames() const {
  return goparserParserStaticData->ruleNames;
}

const dfa::Vocabulary& GoParser::getVocabulary() const {
  return goparserParserStaticData->vocabulary;
}

antlr4::atn::SerializedATNView GoParser::getSerializedATN() const {
  return goparserParserStaticData->serializedATN;
}


//----------------- SourceFileContext ------------------------------------------------------------------

GoParser::SourceFileContext::SourceFileContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GoParser::PackageClauseContext* GoParser::SourceFileContext::packageClause() {
  return getRuleContext<GoParser::PackageClauseContext>(0);
}

std::vector<GoParser::EosContext *> GoParser::SourceFileContext::eos() {
  return getRuleContexts<GoParser::EosContext>();
}

GoParser::EosContext* GoParser::SourceFileContext::eos(size_t i) {
  return getRuleContext<GoParser::EosContext>(i);
}

tree::TerminalNode* GoParser::SourceFileContext::EOF() {
  return getToken(GoParser::EOF, 0);
}

std::vector<GoParser::ImportDeclContext *> GoParser::SourceFileContext::importDecl() {
  return getRuleContexts<GoParser::ImportDeclContext>();
}

GoParser::ImportDeclContext* GoParser::SourceFileContext::importDecl(size_t i) {
  return getRuleContext<GoParser::ImportDeclContext>(i);
}

std::vector<GoParser::FunctionDeclContext *> GoParser::SourceFileContext::functionDecl() {
  return getRuleContexts<GoParser::FunctionDeclContext>();
}

GoParser::FunctionDeclContext* GoParser::SourceFileContext::functionDecl(size_t i) {
  return getRuleContext<GoParser::FunctionDeclContext>(i);
}

std::vector<GoParser::MethodDeclContext *> GoParser::SourceFileContext::methodDecl() {
  return getRuleContexts<GoParser::MethodDeclContext>();
}

GoParser::MethodDeclContext* GoParser::SourceFileContext::methodDecl(size_t i) {
  return getRuleContext<GoParser::MethodDeclContext>(i);
}

std::vector<GoParser::DeclarationContext *> GoParser::SourceFileContext::declaration() {
  return getRuleContexts<GoParser::DeclarationContext>();
}

GoParser::DeclarationContext* GoParser::SourceFileContext::declaration(size_t i) {
  return getRuleContext<GoParser::DeclarationContext>(i);
}


size_t GoParser::SourceFileContext::getRuleIndex() const {
  return GoParser::RuleSourceFile;
}


std::any GoParser::SourceFileContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitSourceFile(this);
  else
    return visitor->visitChildren(this);
}

GoParser::SourceFileContext* GoParser::sourceFile() {
  SourceFileContext *_localctx = _tracker.createInstance<SourceFileContext>(_ctx, getState());
  enterRule(_localctx, 0, GoParser::RuleSourceFile);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(206);
    packageClause();
    setState(207);
    eos();
    setState(213);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == GoParser::IMPORT) {
      setState(208);
      importDecl();
      setState(209);
      eos();
      setState(215);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(225);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 34668552) != 0)) {
      setState(219);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1, _ctx)) {
      case 1: {
        setState(216);
        functionDecl();
        break;
      }

      case 2: {
        setState(217);
        methodDecl();
        break;
      }

      case 3: {
        setState(218);
        declaration();
        break;
      }

      default:
        break;
      }
      setState(221);
      eos();
      setState(227);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(228);
    match(GoParser::EOF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PackageClauseContext ------------------------------------------------------------------

GoParser::PackageClauseContext::PackageClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GoParser::PackageClauseContext::PACKAGE() {
  return getToken(GoParser::PACKAGE, 0);
}

tree::TerminalNode* GoParser::PackageClauseContext::IDENTIFIER() {
  return getToken(GoParser::IDENTIFIER, 0);
}


size_t GoParser::PackageClauseContext::getRuleIndex() const {
  return GoParser::RulePackageClause;
}


std::any GoParser::PackageClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitPackageClause(this);
  else
    return visitor->visitChildren(this);
}

GoParser::PackageClauseContext* GoParser::packageClause() {
  PackageClauseContext *_localctx = _tracker.createInstance<PackageClauseContext>(_ctx, getState());
  enterRule(_localctx, 2, GoParser::RulePackageClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(230);
    match(GoParser::PACKAGE);
    setState(231);
    antlrcpp::downCast<PackageClauseContext *>(_localctx)->packageName = match(GoParser::IDENTIFIER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ImportDeclContext ------------------------------------------------------------------

GoParser::ImportDeclContext::ImportDeclContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GoParser::ImportDeclContext::IMPORT() {
  return getToken(GoParser::IMPORT, 0);
}

std::vector<GoParser::ImportSpecContext *> GoParser::ImportDeclContext::importSpec() {
  return getRuleContexts<GoParser::ImportSpecContext>();
}

GoParser::ImportSpecContext* GoParser::ImportDeclContext::importSpec(size_t i) {
  return getRuleContext<GoParser::ImportSpecContext>(i);
}

tree::TerminalNode* GoParser::ImportDeclContext::L_PAREN() {
  return getToken(GoParser::L_PAREN, 0);
}

tree::TerminalNode* GoParser::ImportDeclContext::R_PAREN() {
  return getToken(GoParser::R_PAREN, 0);
}

std::vector<GoParser::EosContext *> GoParser::ImportDeclContext::eos() {
  return getRuleContexts<GoParser::EosContext>();
}

GoParser::EosContext* GoParser::ImportDeclContext::eos(size_t i) {
  return getRuleContext<GoParser::EosContext>(i);
}


size_t GoParser::ImportDeclContext::getRuleIndex() const {
  return GoParser::RuleImportDecl;
}


std::any GoParser::ImportDeclContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitImportDecl(this);
  else
    return visitor->visitChildren(this);
}

GoParser::ImportDeclContext* GoParser::importDecl() {
  ImportDeclContext *_localctx = _tracker.createInstance<ImportDeclContext>(_ctx, getState());
  enterRule(_localctx, 4, GoParser::RuleImportDecl);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(233);
    match(GoParser::IMPORT);
    setState(245);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GoParser::IDENTIFIER:
      case GoParser::DOT:
      case GoParser::RAW_STRING_LIT:
      case GoParser::INTERPRETED_STRING_LIT: {
        setState(234);
        importSpec();
        break;
      }

      case GoParser::L_PAREN: {
        setState(235);
        match(GoParser::L_PAREN);
        setState(241);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (((((_la - 27) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 27)) & 13510798882113537) != 0)) {
          setState(236);
          importSpec();
          setState(237);
          eos();
          setState(243);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(244);
        match(GoParser::R_PAREN);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ImportSpecContext ------------------------------------------------------------------

GoParser::ImportSpecContext::ImportSpecContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GoParser::ImportPathContext* GoParser::ImportSpecContext::importPath() {
  return getRuleContext<GoParser::ImportPathContext>(0);
}

tree::TerminalNode* GoParser::ImportSpecContext::DOT() {
  return getToken(GoParser::DOT, 0);
}

tree::TerminalNode* GoParser::ImportSpecContext::IDENTIFIER() {
  return getToken(GoParser::IDENTIFIER, 0);
}


size_t GoParser::ImportSpecContext::getRuleIndex() const {
  return GoParser::RuleImportSpec;
}


std::any GoParser::ImportSpecContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitImportSpec(this);
  else
    return visitor->visitChildren(this);
}

GoParser::ImportSpecContext* GoParser::importSpec() {
  ImportSpecContext *_localctx = _tracker.createInstance<ImportSpecContext>(_ctx, getState());
  enterRule(_localctx, 6, GoParser::RuleImportSpec);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(248);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GoParser::IDENTIFIER

    || _la == GoParser::DOT) {
      setState(247);
      antlrcpp::downCast<ImportSpecContext *>(_localctx)->alias = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == GoParser::IDENTIFIER

      || _la == GoParser::DOT)) {
        antlrcpp::downCast<ImportSpecContext *>(_localctx)->alias = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(250);
    importPath();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ImportPathContext ------------------------------------------------------------------

GoParser::ImportPathContext::ImportPathContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GoParser::String_Context* GoParser::ImportPathContext::string_() {
  return getRuleContext<GoParser::String_Context>(0);
}


size_t GoParser::ImportPathContext::getRuleIndex() const {
  return GoParser::RuleImportPath;
}


std::any GoParser::ImportPathContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitImportPath(this);
  else
    return visitor->visitChildren(this);
}

GoParser::ImportPathContext* GoParser::importPath() {
  ImportPathContext *_localctx = _tracker.createInstance<ImportPathContext>(_ctx, getState());
  enterRule(_localctx, 8, GoParser::RuleImportPath);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(252);
    string_();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DeclarationContext ------------------------------------------------------------------

GoParser::DeclarationContext::DeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GoParser::ConstDeclContext* GoParser::DeclarationContext::constDecl() {
  return getRuleContext<GoParser::ConstDeclContext>(0);
}

GoParser::TypeDeclContext* GoParser::DeclarationContext::typeDecl() {
  return getRuleContext<GoParser::TypeDeclContext>(0);
}

GoParser::VarDeclContext* GoParser::DeclarationContext::varDecl() {
  return getRuleContext<GoParser::VarDeclContext>(0);
}


size_t GoParser::DeclarationContext::getRuleIndex() const {
  return GoParser::RuleDeclaration;
}


std::any GoParser::DeclarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitDeclaration(this);
  else
    return visitor->visitChildren(this);
}

GoParser::DeclarationContext* GoParser::declaration() {
  DeclarationContext *_localctx = _tracker.createInstance<DeclarationContext>(_ctx, getState());
  enterRule(_localctx, 10, GoParser::RuleDeclaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(257);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GoParser::CONST: {
        enterOuterAlt(_localctx, 1);
        setState(254);
        constDecl();
        break;
      }

      case GoParser::TYPE: {
        enterOuterAlt(_localctx, 2);
        setState(255);
        typeDecl();
        break;
      }

      case GoParser::VAR: {
        enterOuterAlt(_localctx, 3);
        setState(256);
        varDecl();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstDeclContext ------------------------------------------------------------------

GoParser::ConstDeclContext::ConstDeclContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GoParser::ConstDeclContext::CONST() {
  return getToken(GoParser::CONST, 0);
}

std::vector<GoParser::ConstSpecContext *> GoParser::ConstDeclContext::constSpec() {
  return getRuleContexts<GoParser::ConstSpecContext>();
}

GoParser::ConstSpecContext* GoParser::ConstDeclContext::constSpec(size_t i) {
  return getRuleContext<GoParser::ConstSpecContext>(i);
}

tree::TerminalNode* GoParser::ConstDeclContext::L_PAREN() {
  return getToken(GoParser::L_PAREN, 0);
}

tree::TerminalNode* GoParser::ConstDeclContext::R_PAREN() {
  return getToken(GoParser::R_PAREN, 0);
}

std::vector<GoParser::EosContext *> GoParser::ConstDeclContext::eos() {
  return getRuleContexts<GoParser::EosContext>();
}

GoParser::EosContext* GoParser::ConstDeclContext::eos(size_t i) {
  return getRuleContext<GoParser::EosContext>(i);
}


size_t GoParser::ConstDeclContext::getRuleIndex() const {
  return GoParser::RuleConstDecl;
}


std::any GoParser::ConstDeclContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitConstDecl(this);
  else
    return visitor->visitChildren(this);
}

GoParser::ConstDeclContext* GoParser::constDecl() {
  ConstDeclContext *_localctx = _tracker.createInstance<ConstDeclContext>(_ctx, getState());
  enterRule(_localctx, 12, GoParser::RuleConstDecl);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(259);
    match(GoParser::CONST);
    setState(271);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GoParser::IDENTIFIER: {
        setState(260);
        constSpec();
        break;
      }

      case GoParser::L_PAREN: {
        setState(261);
        match(GoParser::L_PAREN);
        setState(267);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == GoParser::IDENTIFIER) {
          setState(262);
          constSpec();
          setState(263);
          eos();
          setState(269);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(270);
        match(GoParser::R_PAREN);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstSpecContext ------------------------------------------------------------------

GoParser::ConstSpecContext::ConstSpecContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GoParser::IdentifierListContext* GoParser::ConstSpecContext::identifierList() {
  return getRuleContext<GoParser::IdentifierListContext>(0);
}

tree::TerminalNode* GoParser::ConstSpecContext::ASSIGN() {
  return getToken(GoParser::ASSIGN, 0);
}

GoParser::ExpressionListContext* GoParser::ConstSpecContext::expressionList() {
  return getRuleContext<GoParser::ExpressionListContext>(0);
}

GoParser::Type_Context* GoParser::ConstSpecContext::type_() {
  return getRuleContext<GoParser::Type_Context>(0);
}


size_t GoParser::ConstSpecContext::getRuleIndex() const {
  return GoParser::RuleConstSpec;
}


std::any GoParser::ConstSpecContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitConstSpec(this);
  else
    return visitor->visitChildren(this);
}

GoParser::ConstSpecContext* GoParser::constSpec() {
  ConstSpecContext *_localctx = _tracker.createInstance<ConstSpecContext>(_ctx, getState());
  enterRule(_localctx, 14, GoParser::RuleConstSpec);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(273);
    identifierList();
    setState(279);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 10, _ctx)) {
    case 1: {
      setState(275);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 3) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 3)) & 2882303762104320451) != 0)) {
        setState(274);
        type_();
      }
      setState(277);
      match(GoParser::ASSIGN);
      setState(278);
      expressionList();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentifierListContext ------------------------------------------------------------------

GoParser::IdentifierListContext::IdentifierListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> GoParser::IdentifierListContext::IDENTIFIER() {
  return getTokens(GoParser::IDENTIFIER);
}

tree::TerminalNode* GoParser::IdentifierListContext::IDENTIFIER(size_t i) {
  return getToken(GoParser::IDENTIFIER, i);
}

std::vector<tree::TerminalNode *> GoParser::IdentifierListContext::COMMA() {
  return getTokens(GoParser::COMMA);
}

tree::TerminalNode* GoParser::IdentifierListContext::COMMA(size_t i) {
  return getToken(GoParser::COMMA, i);
}


size_t GoParser::IdentifierListContext::getRuleIndex() const {
  return GoParser::RuleIdentifierList;
}


std::any GoParser::IdentifierListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitIdentifierList(this);
  else
    return visitor->visitChildren(this);
}

GoParser::IdentifierListContext* GoParser::identifierList() {
  IdentifierListContext *_localctx = _tracker.createInstance<IdentifierListContext>(_ctx, getState());
  enterRule(_localctx, 16, GoParser::RuleIdentifierList);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(281);
    match(GoParser::IDENTIFIER);
    setState(286);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 11, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(282);
        match(GoParser::COMMA);
        setState(283);
        match(GoParser::IDENTIFIER); 
      }
      setState(288);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 11, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExpressionListContext ------------------------------------------------------------------

GoParser::ExpressionListContext::ExpressionListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GoParser::ExpressionContext *> GoParser::ExpressionListContext::expression() {
  return getRuleContexts<GoParser::ExpressionContext>();
}

GoParser::ExpressionContext* GoParser::ExpressionListContext::expression(size_t i) {
  return getRuleContext<GoParser::ExpressionContext>(i);
}

std::vector<tree::TerminalNode *> GoParser::ExpressionListContext::COMMA() {
  return getTokens(GoParser::COMMA);
}

tree::TerminalNode* GoParser::ExpressionListContext::COMMA(size_t i) {
  return getToken(GoParser::COMMA, i);
}


size_t GoParser::ExpressionListContext::getRuleIndex() const {
  return GoParser::RuleExpressionList;
}


std::any GoParser::ExpressionListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitExpressionList(this);
  else
    return visitor->visitChildren(this);
}

GoParser::ExpressionListContext* GoParser::expressionList() {
  ExpressionListContext *_localctx = _tracker.createInstance<ExpressionListContext>(_ctx, getState());
  enterRule(_localctx, 18, GoParser::RuleExpressionList);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(289);
    expression(0);
    setState(294);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 12, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(290);
        match(GoParser::COMMA);
        setState(291);
        expression(0); 
      }
      setState(296);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 12, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeDeclContext ------------------------------------------------------------------

GoParser::TypeDeclContext::TypeDeclContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GoParser::TypeDeclContext::TYPE() {
  return getToken(GoParser::TYPE, 0);
}

std::vector<GoParser::TypeSpecContext *> GoParser::TypeDeclContext::typeSpec() {
  return getRuleContexts<GoParser::TypeSpecContext>();
}

GoParser::TypeSpecContext* GoParser::TypeDeclContext::typeSpec(size_t i) {
  return getRuleContext<GoParser::TypeSpecContext>(i);
}

tree::TerminalNode* GoParser::TypeDeclContext::L_PAREN() {
  return getToken(GoParser::L_PAREN, 0);
}

tree::TerminalNode* GoParser::TypeDeclContext::R_PAREN() {
  return getToken(GoParser::R_PAREN, 0);
}

std::vector<GoParser::EosContext *> GoParser::TypeDeclContext::eos() {
  return getRuleContexts<GoParser::EosContext>();
}

GoParser::EosContext* GoParser::TypeDeclContext::eos(size_t i) {
  return getRuleContext<GoParser::EosContext>(i);
}


size_t GoParser::TypeDeclContext::getRuleIndex() const {
  return GoParser::RuleTypeDecl;
}


std::any GoParser::TypeDeclContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitTypeDecl(this);
  else
    return visitor->visitChildren(this);
}

GoParser::TypeDeclContext* GoParser::typeDecl() {
  TypeDeclContext *_localctx = _tracker.createInstance<TypeDeclContext>(_ctx, getState());
  enterRule(_localctx, 20, GoParser::RuleTypeDecl);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(297);
    match(GoParser::TYPE);
    setState(309);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GoParser::IDENTIFIER: {
        setState(298);
        typeSpec();
        break;
      }

      case GoParser::L_PAREN: {
        setState(299);
        match(GoParser::L_PAREN);
        setState(305);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == GoParser::IDENTIFIER) {
          setState(300);
          typeSpec();
          setState(301);
          eos();
          setState(307);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(308);
        match(GoParser::R_PAREN);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeSpecContext ------------------------------------------------------------------

GoParser::TypeSpecContext::TypeSpecContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GoParser::AliasDeclContext* GoParser::TypeSpecContext::aliasDecl() {
  return getRuleContext<GoParser::AliasDeclContext>(0);
}

GoParser::TypeDefContext* GoParser::TypeSpecContext::typeDef() {
  return getRuleContext<GoParser::TypeDefContext>(0);
}


size_t GoParser::TypeSpecContext::getRuleIndex() const {
  return GoParser::RuleTypeSpec;
}


std::any GoParser::TypeSpecContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitTypeSpec(this);
  else
    return visitor->visitChildren(this);
}

GoParser::TypeSpecContext* GoParser::typeSpec() {
  TypeSpecContext *_localctx = _tracker.createInstance<TypeSpecContext>(_ctx, getState());
  enterRule(_localctx, 22, GoParser::RuleTypeSpec);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(313);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 15, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(311);
      aliasDecl();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(312);
      typeDef();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AliasDeclContext ------------------------------------------------------------------

GoParser::AliasDeclContext::AliasDeclContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GoParser::AliasDeclContext::IDENTIFIER() {
  return getToken(GoParser::IDENTIFIER, 0);
}

tree::TerminalNode* GoParser::AliasDeclContext::ASSIGN() {
  return getToken(GoParser::ASSIGN, 0);
}

GoParser::Type_Context* GoParser::AliasDeclContext::type_() {
  return getRuleContext<GoParser::Type_Context>(0);
}


size_t GoParser::AliasDeclContext::getRuleIndex() const {
  return GoParser::RuleAliasDecl;
}


std::any GoParser::AliasDeclContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitAliasDecl(this);
  else
    return visitor->visitChildren(this);
}

GoParser::AliasDeclContext* GoParser::aliasDecl() {
  AliasDeclContext *_localctx = _tracker.createInstance<AliasDeclContext>(_ctx, getState());
  enterRule(_localctx, 24, GoParser::RuleAliasDecl);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(315);
    match(GoParser::IDENTIFIER);
    setState(316);
    match(GoParser::ASSIGN);
    setState(317);
    type_();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeDefContext ------------------------------------------------------------------

GoParser::TypeDefContext::TypeDefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GoParser::TypeDefContext::IDENTIFIER() {
  return getToken(GoParser::IDENTIFIER, 0);
}

GoParser::Type_Context* GoParser::TypeDefContext::type_() {
  return getRuleContext<GoParser::Type_Context>(0);
}

GoParser::TypeParametersContext* GoParser::TypeDefContext::typeParameters() {
  return getRuleContext<GoParser::TypeParametersContext>(0);
}


size_t GoParser::TypeDefContext::getRuleIndex() const {
  return GoParser::RuleTypeDef;
}


std::any GoParser::TypeDefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitTypeDef(this);
  else
    return visitor->visitChildren(this);
}

GoParser::TypeDefContext* GoParser::typeDef() {
  TypeDefContext *_localctx = _tracker.createInstance<TypeDefContext>(_ctx, getState());
  enterRule(_localctx, 26, GoParser::RuleTypeDef);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(319);
    match(GoParser::IDENTIFIER);
    setState(321);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 16, _ctx)) {
    case 1: {
      setState(320);
      typeParameters();
      break;
    }

    default:
      break;
    }
    setState(323);
    type_();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeParametersContext ------------------------------------------------------------------

GoParser::TypeParametersContext::TypeParametersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GoParser::TypeParametersContext::L_BRACKET() {
  return getToken(GoParser::L_BRACKET, 0);
}

std::vector<GoParser::TypeParameterDeclContext *> GoParser::TypeParametersContext::typeParameterDecl() {
  return getRuleContexts<GoParser::TypeParameterDeclContext>();
}

GoParser::TypeParameterDeclContext* GoParser::TypeParametersContext::typeParameterDecl(size_t i) {
  return getRuleContext<GoParser::TypeParameterDeclContext>(i);
}

tree::TerminalNode* GoParser::TypeParametersContext::R_BRACKET() {
  return getToken(GoParser::R_BRACKET, 0);
}

std::vector<tree::TerminalNode *> GoParser::TypeParametersContext::COMMA() {
  return getTokens(GoParser::COMMA);
}

tree::TerminalNode* GoParser::TypeParametersContext::COMMA(size_t i) {
  return getToken(GoParser::COMMA, i);
}


size_t GoParser::TypeParametersContext::getRuleIndex() const {
  return GoParser::RuleTypeParameters;
}


std::any GoParser::TypeParametersContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitTypeParameters(this);
  else
    return visitor->visitChildren(this);
}

GoParser::TypeParametersContext* GoParser::typeParameters() {
  TypeParametersContext *_localctx = _tracker.createInstance<TypeParametersContext>(_ctx, getState());
  enterRule(_localctx, 28, GoParser::RuleTypeParameters);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(325);
    match(GoParser::L_BRACKET);
    setState(326);
    typeParameterDecl();
    setState(331);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == GoParser::COMMA) {
      setState(327);
      match(GoParser::COMMA);
      setState(328);
      typeParameterDecl();
      setState(333);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(334);
    match(GoParser::R_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeParameterDeclContext ------------------------------------------------------------------

GoParser::TypeParameterDeclContext::TypeParameterDeclContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GoParser::IdentifierListContext* GoParser::TypeParameterDeclContext::identifierList() {
  return getRuleContext<GoParser::IdentifierListContext>(0);
}

GoParser::TypeElementContext* GoParser::TypeParameterDeclContext::typeElement() {
  return getRuleContext<GoParser::TypeElementContext>(0);
}


size_t GoParser::TypeParameterDeclContext::getRuleIndex() const {
  return GoParser::RuleTypeParameterDecl;
}


std::any GoParser::TypeParameterDeclContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitTypeParameterDecl(this);
  else
    return visitor->visitChildren(this);
}

GoParser::TypeParameterDeclContext* GoParser::typeParameterDecl() {
  TypeParameterDeclContext *_localctx = _tracker.createInstance<TypeParameterDeclContext>(_ctx, getState());
  enterRule(_localctx, 30, GoParser::RuleTypeParameterDecl);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(336);
    identifierList();
    setState(337);
    typeElement();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeElementContext ------------------------------------------------------------------

GoParser::TypeElementContext::TypeElementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GoParser::TypeTermContext *> GoParser::TypeElementContext::typeTerm() {
  return getRuleContexts<GoParser::TypeTermContext>();
}

GoParser::TypeTermContext* GoParser::TypeElementContext::typeTerm(size_t i) {
  return getRuleContext<GoParser::TypeTermContext>(i);
}

std::vector<tree::TerminalNode *> GoParser::TypeElementContext::OR() {
  return getTokens(GoParser::OR);
}

tree::TerminalNode* GoParser::TypeElementContext::OR(size_t i) {
  return getToken(GoParser::OR, i);
}


size_t GoParser::TypeElementContext::getRuleIndex() const {
  return GoParser::RuleTypeElement;
}


std::any GoParser::TypeElementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitTypeElement(this);
  else
    return visitor->visitChildren(this);
}

GoParser::TypeElementContext* GoParser::typeElement() {
  TypeElementContext *_localctx = _tracker.createInstance<TypeElementContext>(_ctx, getState());
  enterRule(_localctx, 32, GoParser::RuleTypeElement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(339);
    typeTerm();
    setState(344);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 18, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(340);
        match(GoParser::OR);
        setState(341);
        typeTerm(); 
      }
      setState(346);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 18, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeTermContext ------------------------------------------------------------------

GoParser::TypeTermContext::TypeTermContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GoParser::Type_Context* GoParser::TypeTermContext::type_() {
  return getRuleContext<GoParser::Type_Context>(0);
}

tree::TerminalNode* GoParser::TypeTermContext::UNDERLYING() {
  return getToken(GoParser::UNDERLYING, 0);
}


size_t GoParser::TypeTermContext::getRuleIndex() const {
  return GoParser::RuleTypeTerm;
}


std::any GoParser::TypeTermContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitTypeTerm(this);
  else
    return visitor->visitChildren(this);
}

GoParser::TypeTermContext* GoParser::typeTerm() {
  TypeTermContext *_localctx = _tracker.createInstance<TypeTermContext>(_ctx, getState());
  enterRule(_localctx, 34, GoParser::RuleTypeTerm);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(348);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GoParser::UNDERLYING) {
      setState(347);
      match(GoParser::UNDERLYING);
    }
    setState(350);
    type_();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionDeclContext ------------------------------------------------------------------

GoParser::FunctionDeclContext::FunctionDeclContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GoParser::FunctionDeclContext::FUNC() {
  return getToken(GoParser::FUNC, 0);
}

tree::TerminalNode* GoParser::FunctionDeclContext::IDENTIFIER() {
  return getToken(GoParser::IDENTIFIER, 0);
}

GoParser::SignatureContext* GoParser::FunctionDeclContext::signature() {
  return getRuleContext<GoParser::SignatureContext>(0);
}

GoParser::TypeParametersContext* GoParser::FunctionDeclContext::typeParameters() {
  return getRuleContext<GoParser::TypeParametersContext>(0);
}

GoParser::BlockContext* GoParser::FunctionDeclContext::block() {
  return getRuleContext<GoParser::BlockContext>(0);
}


size_t GoParser::FunctionDeclContext::getRuleIndex() const {
  return GoParser::RuleFunctionDecl;
}


std::any GoParser::FunctionDeclContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitFunctionDecl(this);
  else
    return visitor->visitChildren(this);
}

GoParser::FunctionDeclContext* GoParser::functionDecl() {
  FunctionDeclContext *_localctx = _tracker.createInstance<FunctionDeclContext>(_ctx, getState());
  enterRule(_localctx, 36, GoParser::RuleFunctionDecl);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(352);
    match(GoParser::FUNC);
    setState(353);
    match(GoParser::IDENTIFIER);
    setState(355);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GoParser::L_BRACKET) {
      setState(354);
      typeParameters();
    }
    setState(357);
    signature();
    setState(359);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 21, _ctx)) {
    case 1: {
      setState(358);
      block();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MethodDeclContext ------------------------------------------------------------------

GoParser::MethodDeclContext::MethodDeclContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GoParser::MethodDeclContext::FUNC() {
  return getToken(GoParser::FUNC, 0);
}

GoParser::ReceiverContext* GoParser::MethodDeclContext::receiver() {
  return getRuleContext<GoParser::ReceiverContext>(0);
}

tree::TerminalNode* GoParser::MethodDeclContext::IDENTIFIER() {
  return getToken(GoParser::IDENTIFIER, 0);
}

GoParser::SignatureContext* GoParser::MethodDeclContext::signature() {
  return getRuleContext<GoParser::SignatureContext>(0);
}

GoParser::BlockContext* GoParser::MethodDeclContext::block() {
  return getRuleContext<GoParser::BlockContext>(0);
}


size_t GoParser::MethodDeclContext::getRuleIndex() const {
  return GoParser::RuleMethodDecl;
}


std::any GoParser::MethodDeclContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitMethodDecl(this);
  else
    return visitor->visitChildren(this);
}

GoParser::MethodDeclContext* GoParser::methodDecl() {
  MethodDeclContext *_localctx = _tracker.createInstance<MethodDeclContext>(_ctx, getState());
  enterRule(_localctx, 38, GoParser::RuleMethodDecl);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(361);
    match(GoParser::FUNC);
    setState(362);
    receiver();
    setState(363);
    match(GoParser::IDENTIFIER);
    setState(364);
    signature();
    setState(366);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 22, _ctx)) {
    case 1: {
      setState(365);
      block();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReceiverContext ------------------------------------------------------------------

GoParser::ReceiverContext::ReceiverContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GoParser::ParametersContext* GoParser::ReceiverContext::parameters() {
  return getRuleContext<GoParser::ParametersContext>(0);
}


size_t GoParser::ReceiverContext::getRuleIndex() const {
  return GoParser::RuleReceiver;
}


std::any GoParser::ReceiverContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitReceiver(this);
  else
    return visitor->visitChildren(this);
}

GoParser::ReceiverContext* GoParser::receiver() {
  ReceiverContext *_localctx = _tracker.createInstance<ReceiverContext>(_ctx, getState());
  enterRule(_localctx, 40, GoParser::RuleReceiver);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(368);
    parameters();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VarDeclContext ------------------------------------------------------------------

GoParser::VarDeclContext::VarDeclContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GoParser::VarDeclContext::VAR() {
  return getToken(GoParser::VAR, 0);
}

std::vector<GoParser::VarSpecContext *> GoParser::VarDeclContext::varSpec() {
  return getRuleContexts<GoParser::VarSpecContext>();
}

GoParser::VarSpecContext* GoParser::VarDeclContext::varSpec(size_t i) {
  return getRuleContext<GoParser::VarSpecContext>(i);
}

tree::TerminalNode* GoParser::VarDeclContext::L_PAREN() {
  return getToken(GoParser::L_PAREN, 0);
}

tree::TerminalNode* GoParser::VarDeclContext::R_PAREN() {
  return getToken(GoParser::R_PAREN, 0);
}

std::vector<GoParser::EosContext *> GoParser::VarDeclContext::eos() {
  return getRuleContexts<GoParser::EosContext>();
}

GoParser::EosContext* GoParser::VarDeclContext::eos(size_t i) {
  return getRuleContext<GoParser::EosContext>(i);
}


size_t GoParser::VarDeclContext::getRuleIndex() const {
  return GoParser::RuleVarDecl;
}


std::any GoParser::VarDeclContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitVarDecl(this);
  else
    return visitor->visitChildren(this);
}

GoParser::VarDeclContext* GoParser::varDecl() {
  VarDeclContext *_localctx = _tracker.createInstance<VarDeclContext>(_ctx, getState());
  enterRule(_localctx, 42, GoParser::RuleVarDecl);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(370);
    match(GoParser::VAR);
    setState(382);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GoParser::IDENTIFIER: {
        setState(371);
        varSpec();
        break;
      }

      case GoParser::L_PAREN: {
        setState(372);
        match(GoParser::L_PAREN);
        setState(378);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == GoParser::IDENTIFIER) {
          setState(373);
          varSpec();
          setState(374);
          eos();
          setState(380);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(381);
        match(GoParser::R_PAREN);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VarSpecContext ------------------------------------------------------------------

GoParser::VarSpecContext::VarSpecContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GoParser::IdentifierListContext* GoParser::VarSpecContext::identifierList() {
  return getRuleContext<GoParser::IdentifierListContext>(0);
}

GoParser::Type_Context* GoParser::VarSpecContext::type_() {
  return getRuleContext<GoParser::Type_Context>(0);
}

tree::TerminalNode* GoParser::VarSpecContext::ASSIGN() {
  return getToken(GoParser::ASSIGN, 0);
}

GoParser::ExpressionListContext* GoParser::VarSpecContext::expressionList() {
  return getRuleContext<GoParser::ExpressionListContext>(0);
}


size_t GoParser::VarSpecContext::getRuleIndex() const {
  return GoParser::RuleVarSpec;
}


std::any GoParser::VarSpecContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitVarSpec(this);
  else
    return visitor->visitChildren(this);
}

GoParser::VarSpecContext* GoParser::varSpec() {
  VarSpecContext *_localctx = _tracker.createInstance<VarSpecContext>(_ctx, getState());
  enterRule(_localctx, 44, GoParser::RuleVarSpec);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(384);
    identifierList();
    setState(392);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GoParser::FUNC:
      case GoParser::INTERFACE:
      case GoParser::MAP:
      case GoParser::STRUCT:
      case GoParser::CHAN:
      case GoParser::IDENTIFIER:
      case GoParser::L_PAREN:
      case GoParser::L_BRACKET:
      case GoParser::STAR:
      case GoParser::RECEIVE: {
        setState(385);
        type_();
        setState(388);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 25, _ctx)) {
        case 1: {
          setState(386);
          match(GoParser::ASSIGN);
          setState(387);
          expressionList();
          break;
        }

        default:
          break;
        }
        break;
      }

      case GoParser::ASSIGN: {
        setState(390);
        match(GoParser::ASSIGN);
        setState(391);
        expressionList();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BlockContext ------------------------------------------------------------------

GoParser::BlockContext::BlockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GoParser::BlockContext::L_CURLY() {
  return getToken(GoParser::L_CURLY, 0);
}

tree::TerminalNode* GoParser::BlockContext::R_CURLY() {
  return getToken(GoParser::R_CURLY, 0);
}

GoParser::StatementListContext* GoParser::BlockContext::statementList() {
  return getRuleContext<GoParser::StatementListContext>(0);
}


size_t GoParser::BlockContext::getRuleIndex() const {
  return GoParser::RuleBlock;
}


std::any GoParser::BlockContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitBlock(this);
  else
    return visitor->visitChildren(this);
}

GoParser::BlockContext* GoParser::block() {
  BlockContext *_localctx = _tracker.createInstance<BlockContext>(_ctx, getState());
  enterRule(_localctx, 46, GoParser::RuleBlock);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(394);
    match(GoParser::L_CURLY);
    setState(396);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 27, _ctx)) {
    case 1: {
      setState(395);
      statementList();
      break;
    }

    default:
      break;
    }
    setState(398);
    match(GoParser::R_CURLY);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StatementListContext ------------------------------------------------------------------

GoParser::StatementListContext::StatementListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GoParser::StatementContext *> GoParser::StatementListContext::statement() {
  return getRuleContexts<GoParser::StatementContext>();
}

GoParser::StatementContext* GoParser::StatementListContext::statement(size_t i) {
  return getRuleContext<GoParser::StatementContext>(i);
}

std::vector<GoParser::EosContext *> GoParser::StatementListContext::eos() {
  return getRuleContexts<GoParser::EosContext>();
}

GoParser::EosContext* GoParser::StatementListContext::eos(size_t i) {
  return getRuleContext<GoParser::EosContext>(i);
}

std::vector<tree::TerminalNode *> GoParser::StatementListContext::SEMI() {
  return getTokens(GoParser::SEMI);
}

tree::TerminalNode* GoParser::StatementListContext::SEMI(size_t i) {
  return getToken(GoParser::SEMI, i);
}

std::vector<tree::TerminalNode *> GoParser::StatementListContext::EOS() {
  return getTokens(GoParser::EOS);
}

tree::TerminalNode* GoParser::StatementListContext::EOS(size_t i) {
  return getToken(GoParser::EOS, i);
}


size_t GoParser::StatementListContext::getRuleIndex() const {
  return GoParser::RuleStatementList;
}


std::any GoParser::StatementListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitStatementList(this);
  else
    return visitor->visitChildren(this);
}

GoParser::StatementListContext* GoParser::statementList() {
  StatementListContext *_localctx = _tracker.createInstance<StatementListContext>(_ctx, getState());
  enterRule(_localctx, 48, GoParser::RuleStatementList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(412); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(407);
              _errHandler->sync(this);
              switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 30, _ctx)) {
              case 1: {
                setState(401);
                _errHandler->sync(this);

                _la = _input->LA(1);
                if (_la == GoParser::SEMI) {
                  setState(400);
                  match(GoParser::SEMI);
                }
                break;
              }

              case 2: {
                setState(404);
                _errHandler->sync(this);

                _la = _input->LA(1);
                if (_la == GoParser::EOS) {
                  setState(403);
                  match(GoParser::EOS);
                }
                break;
              }

              case 3: {
                setState(406);

                if (!(this->closingBracket())) throw FailedPredicateException(this, "this->closingBracket()");
                break;
              }

              default:
                break;
              }
              setState(409);
              statement();
              setState(410);
              eos();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(414); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 31, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StatementContext ------------------------------------------------------------------

GoParser::StatementContext::StatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GoParser::DeclarationContext* GoParser::StatementContext::declaration() {
  return getRuleContext<GoParser::DeclarationContext>(0);
}

GoParser::LabeledStmtContext* GoParser::StatementContext::labeledStmt() {
  return getRuleContext<GoParser::LabeledStmtContext>(0);
}

GoParser::SimpleStmtContext* GoParser::StatementContext::simpleStmt() {
  return getRuleContext<GoParser::SimpleStmtContext>(0);
}

GoParser::GoStmtContext* GoParser::StatementContext::goStmt() {
  return getRuleContext<GoParser::GoStmtContext>(0);
}

GoParser::ReturnStmtContext* GoParser::StatementContext::returnStmt() {
  return getRuleContext<GoParser::ReturnStmtContext>(0);
}

GoParser::BreakStmtContext* GoParser::StatementContext::breakStmt() {
  return getRuleContext<GoParser::BreakStmtContext>(0);
}

GoParser::ContinueStmtContext* GoParser::StatementContext::continueStmt() {
  return getRuleContext<GoParser::ContinueStmtContext>(0);
}

GoParser::GotoStmtContext* GoParser::StatementContext::gotoStmt() {
  return getRuleContext<GoParser::GotoStmtContext>(0);
}

GoParser::FallthroughStmtContext* GoParser::StatementContext::fallthroughStmt() {
  return getRuleContext<GoParser::FallthroughStmtContext>(0);
}

GoParser::BlockContext* GoParser::StatementContext::block() {
  return getRuleContext<GoParser::BlockContext>(0);
}

GoParser::IfStmtContext* GoParser::StatementContext::ifStmt() {
  return getRuleContext<GoParser::IfStmtContext>(0);
}

GoParser::SwitchStmtContext* GoParser::StatementContext::switchStmt() {
  return getRuleContext<GoParser::SwitchStmtContext>(0);
}

GoParser::SelectStmtContext* GoParser::StatementContext::selectStmt() {
  return getRuleContext<GoParser::SelectStmtContext>(0);
}

GoParser::ForStmtContext* GoParser::StatementContext::forStmt() {
  return getRuleContext<GoParser::ForStmtContext>(0);
}

GoParser::DeferStmtContext* GoParser::StatementContext::deferStmt() {
  return getRuleContext<GoParser::DeferStmtContext>(0);
}


size_t GoParser::StatementContext::getRuleIndex() const {
  return GoParser::RuleStatement;
}


std::any GoParser::StatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitStatement(this);
  else
    return visitor->visitChildren(this);
}

GoParser::StatementContext* GoParser::statement() {
  StatementContext *_localctx = _tracker.createInstance<StatementContext>(_ctx, getState());
  enterRule(_localctx, 50, GoParser::RuleStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(431);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 32, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(416);
      declaration();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(417);
      labeledStmt();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(418);
      simpleStmt();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(419);
      goStmt();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(420);
      returnStmt();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(421);
      breakStmt();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(422);
      continueStmt();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(423);
      gotoStmt();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(424);
      fallthroughStmt();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(425);
      block();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(426);
      ifStmt();
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(427);
      switchStmt();
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(428);
      selectStmt();
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(429);
      forStmt();
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(430);
      deferStmt();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SimpleStmtContext ------------------------------------------------------------------

GoParser::SimpleStmtContext::SimpleStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GoParser::SendStmtContext* GoParser::SimpleStmtContext::sendStmt() {
  return getRuleContext<GoParser::SendStmtContext>(0);
}

GoParser::IncDecStmtContext* GoParser::SimpleStmtContext::incDecStmt() {
  return getRuleContext<GoParser::IncDecStmtContext>(0);
}

GoParser::AssignmentContext* GoParser::SimpleStmtContext::assignment() {
  return getRuleContext<GoParser::AssignmentContext>(0);
}

GoParser::ExpressionStmtContext* GoParser::SimpleStmtContext::expressionStmt() {
  return getRuleContext<GoParser::ExpressionStmtContext>(0);
}

GoParser::ShortVarDeclContext* GoParser::SimpleStmtContext::shortVarDecl() {
  return getRuleContext<GoParser::ShortVarDeclContext>(0);
}


size_t GoParser::SimpleStmtContext::getRuleIndex() const {
  return GoParser::RuleSimpleStmt;
}


std::any GoParser::SimpleStmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitSimpleStmt(this);
  else
    return visitor->visitChildren(this);
}

GoParser::SimpleStmtContext* GoParser::simpleStmt() {
  SimpleStmtContext *_localctx = _tracker.createInstance<SimpleStmtContext>(_ctx, getState());
  enterRule(_localctx, 52, GoParser::RuleSimpleStmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(438);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 33, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(433);
      sendStmt();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(434);
      incDecStmt();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(435);
      assignment();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(436);
      expressionStmt();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(437);
      shortVarDecl();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExpressionStmtContext ------------------------------------------------------------------

GoParser::ExpressionStmtContext::ExpressionStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GoParser::ExpressionContext* GoParser::ExpressionStmtContext::expression() {
  return getRuleContext<GoParser::ExpressionContext>(0);
}


size_t GoParser::ExpressionStmtContext::getRuleIndex() const {
  return GoParser::RuleExpressionStmt;
}


std::any GoParser::ExpressionStmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitExpressionStmt(this);
  else
    return visitor->visitChildren(this);
}

GoParser::ExpressionStmtContext* GoParser::expressionStmt() {
  ExpressionStmtContext *_localctx = _tracker.createInstance<ExpressionStmtContext>(_ctx, getState());
  enterRule(_localctx, 54, GoParser::RuleExpressionStmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(440);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SendStmtContext ------------------------------------------------------------------

GoParser::SendStmtContext::SendStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GoParser::SendStmtContext::RECEIVE() {
  return getToken(GoParser::RECEIVE, 0);
}

std::vector<GoParser::ExpressionContext *> GoParser::SendStmtContext::expression() {
  return getRuleContexts<GoParser::ExpressionContext>();
}

GoParser::ExpressionContext* GoParser::SendStmtContext::expression(size_t i) {
  return getRuleContext<GoParser::ExpressionContext>(i);
}


size_t GoParser::SendStmtContext::getRuleIndex() const {
  return GoParser::RuleSendStmt;
}


std::any GoParser::SendStmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitSendStmt(this);
  else
    return visitor->visitChildren(this);
}

GoParser::SendStmtContext* GoParser::sendStmt() {
  SendStmtContext *_localctx = _tracker.createInstance<SendStmtContext>(_ctx, getState());
  enterRule(_localctx, 56, GoParser::RuleSendStmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(442);
    antlrcpp::downCast<SendStmtContext *>(_localctx)->channel = expression(0);
    setState(443);
    match(GoParser::RECEIVE);
    setState(444);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IncDecStmtContext ------------------------------------------------------------------

GoParser::IncDecStmtContext::IncDecStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GoParser::ExpressionContext* GoParser::IncDecStmtContext::expression() {
  return getRuleContext<GoParser::ExpressionContext>(0);
}

tree::TerminalNode* GoParser::IncDecStmtContext::PLUS_PLUS() {
  return getToken(GoParser::PLUS_PLUS, 0);
}

tree::TerminalNode* GoParser::IncDecStmtContext::MINUS_MINUS() {
  return getToken(GoParser::MINUS_MINUS, 0);
}


size_t GoParser::IncDecStmtContext::getRuleIndex() const {
  return GoParser::RuleIncDecStmt;
}


std::any GoParser::IncDecStmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitIncDecStmt(this);
  else
    return visitor->visitChildren(this);
}

GoParser::IncDecStmtContext* GoParser::incDecStmt() {
  IncDecStmtContext *_localctx = _tracker.createInstance<IncDecStmtContext>(_ctx, getState());
  enterRule(_localctx, 58, GoParser::RuleIncDecStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(446);
    expression(0);
    setState(447);
    _la = _input->LA(1);
    if (!(_la == GoParser::PLUS_PLUS

    || _la == GoParser::MINUS_MINUS)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssignmentContext ------------------------------------------------------------------

GoParser::AssignmentContext::AssignmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GoParser::ExpressionListContext *> GoParser::AssignmentContext::expressionList() {
  return getRuleContexts<GoParser::ExpressionListContext>();
}

GoParser::ExpressionListContext* GoParser::AssignmentContext::expressionList(size_t i) {
  return getRuleContext<GoParser::ExpressionListContext>(i);
}

GoParser::Assign_opContext* GoParser::AssignmentContext::assign_op() {
  return getRuleContext<GoParser::Assign_opContext>(0);
}


size_t GoParser::AssignmentContext::getRuleIndex() const {
  return GoParser::RuleAssignment;
}


std::any GoParser::AssignmentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitAssignment(this);
  else
    return visitor->visitChildren(this);
}

GoParser::AssignmentContext* GoParser::assignment() {
  AssignmentContext *_localctx = _tracker.createInstance<AssignmentContext>(_ctx, getState());
  enterRule(_localctx, 60, GoParser::RuleAssignment);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(449);
    expressionList();
    setState(450);
    assign_op();
    setState(451);
    expressionList();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Assign_opContext ------------------------------------------------------------------

GoParser::Assign_opContext::Assign_opContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GoParser::Assign_opContext::ASSIGN() {
  return getToken(GoParser::ASSIGN, 0);
}

tree::TerminalNode* GoParser::Assign_opContext::PLUS() {
  return getToken(GoParser::PLUS, 0);
}

tree::TerminalNode* GoParser::Assign_opContext::MINUS() {
  return getToken(GoParser::MINUS, 0);
}

tree::TerminalNode* GoParser::Assign_opContext::OR() {
  return getToken(GoParser::OR, 0);
}

tree::TerminalNode* GoParser::Assign_opContext::CARET() {
  return getToken(GoParser::CARET, 0);
}

tree::TerminalNode* GoParser::Assign_opContext::STAR() {
  return getToken(GoParser::STAR, 0);
}

tree::TerminalNode* GoParser::Assign_opContext::DIV() {
  return getToken(GoParser::DIV, 0);
}

tree::TerminalNode* GoParser::Assign_opContext::MOD() {
  return getToken(GoParser::MOD, 0);
}

tree::TerminalNode* GoParser::Assign_opContext::LSHIFT() {
  return getToken(GoParser::LSHIFT, 0);
}

tree::TerminalNode* GoParser::Assign_opContext::RSHIFT() {
  return getToken(GoParser::RSHIFT, 0);
}

tree::TerminalNode* GoParser::Assign_opContext::AMPERSAND() {
  return getToken(GoParser::AMPERSAND, 0);
}

tree::TerminalNode* GoParser::Assign_opContext::BIT_CLEAR() {
  return getToken(GoParser::BIT_CLEAR, 0);
}


size_t GoParser::Assign_opContext::getRuleIndex() const {
  return GoParser::RuleAssign_op;
}


std::any GoParser::Assign_opContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitAssign_op(this);
  else
    return visitor->visitChildren(this);
}

GoParser::Assign_opContext* GoParser::assign_op() {
  Assign_opContext *_localctx = _tracker.createInstance<Assign_opContext>(_ctx, getState());
  enterRule(_localctx, 62, GoParser::RuleAssign_op);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(454);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -434597364041252864) != 0)) {
      setState(453);
      _la = _input->LA(1);
      if (!((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & -434597364041252864) != 0))) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(456);
    match(GoParser::ASSIGN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShortVarDeclContext ------------------------------------------------------------------

GoParser::ShortVarDeclContext::ShortVarDeclContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GoParser::IdentifierListContext* GoParser::ShortVarDeclContext::identifierList() {
  return getRuleContext<GoParser::IdentifierListContext>(0);
}

tree::TerminalNode* GoParser::ShortVarDeclContext::DECLARE_ASSIGN() {
  return getToken(GoParser::DECLARE_ASSIGN, 0);
}

GoParser::ExpressionListContext* GoParser::ShortVarDeclContext::expressionList() {
  return getRuleContext<GoParser::ExpressionListContext>(0);
}


size_t GoParser::ShortVarDeclContext::getRuleIndex() const {
  return GoParser::RuleShortVarDecl;
}


std::any GoParser::ShortVarDeclContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitShortVarDecl(this);
  else
    return visitor->visitChildren(this);
}

GoParser::ShortVarDeclContext* GoParser::shortVarDecl() {
  ShortVarDeclContext *_localctx = _tracker.createInstance<ShortVarDeclContext>(_ctx, getState());
  enterRule(_localctx, 64, GoParser::RuleShortVarDecl);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(458);
    identifierList();
    setState(459);
    match(GoParser::DECLARE_ASSIGN);
    setState(460);
    expressionList();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LabeledStmtContext ------------------------------------------------------------------

GoParser::LabeledStmtContext::LabeledStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GoParser::LabeledStmtContext::IDENTIFIER() {
  return getToken(GoParser::IDENTIFIER, 0);
}

tree::TerminalNode* GoParser::LabeledStmtContext::COLON() {
  return getToken(GoParser::COLON, 0);
}

GoParser::StatementContext* GoParser::LabeledStmtContext::statement() {
  return getRuleContext<GoParser::StatementContext>(0);
}


size_t GoParser::LabeledStmtContext::getRuleIndex() const {
  return GoParser::RuleLabeledStmt;
}


std::any GoParser::LabeledStmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitLabeledStmt(this);
  else
    return visitor->visitChildren(this);
}

GoParser::LabeledStmtContext* GoParser::labeledStmt() {
  LabeledStmtContext *_localctx = _tracker.createInstance<LabeledStmtContext>(_ctx, getState());
  enterRule(_localctx, 66, GoParser::RuleLabeledStmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(462);
    match(GoParser::IDENTIFIER);
    setState(463);
    match(GoParser::COLON);
    setState(465);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 35, _ctx)) {
    case 1: {
      setState(464);
      statement();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReturnStmtContext ------------------------------------------------------------------

GoParser::ReturnStmtContext::ReturnStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GoParser::ReturnStmtContext::RETURN() {
  return getToken(GoParser::RETURN, 0);
}

GoParser::ExpressionListContext* GoParser::ReturnStmtContext::expressionList() {
  return getRuleContext<GoParser::ExpressionListContext>(0);
}


size_t GoParser::ReturnStmtContext::getRuleIndex() const {
  return GoParser::RuleReturnStmt;
}


std::any GoParser::ReturnStmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitReturnStmt(this);
  else
    return visitor->visitChildren(this);
}

GoParser::ReturnStmtContext* GoParser::returnStmt() {
  ReturnStmtContext *_localctx = _tracker.createInstance<ReturnStmtContext>(_ctx, getState());
  enterRule(_localctx, 68, GoParser::RuleReturnStmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(467);
    match(GoParser::RETURN);
    setState(469);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 36, _ctx)) {
    case 1: {
      setState(468);
      expressionList();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BreakStmtContext ------------------------------------------------------------------

GoParser::BreakStmtContext::BreakStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GoParser::BreakStmtContext::BREAK() {
  return getToken(GoParser::BREAK, 0);
}

tree::TerminalNode* GoParser::BreakStmtContext::IDENTIFIER() {
  return getToken(GoParser::IDENTIFIER, 0);
}


size_t GoParser::BreakStmtContext::getRuleIndex() const {
  return GoParser::RuleBreakStmt;
}


std::any GoParser::BreakStmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitBreakStmt(this);
  else
    return visitor->visitChildren(this);
}

GoParser::BreakStmtContext* GoParser::breakStmt() {
  BreakStmtContext *_localctx = _tracker.createInstance<BreakStmtContext>(_ctx, getState());
  enterRule(_localctx, 70, GoParser::RuleBreakStmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(471);
    match(GoParser::BREAK);
    setState(473);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 37, _ctx)) {
    case 1: {
      setState(472);
      match(GoParser::IDENTIFIER);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ContinueStmtContext ------------------------------------------------------------------

GoParser::ContinueStmtContext::ContinueStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GoParser::ContinueStmtContext::CONTINUE() {
  return getToken(GoParser::CONTINUE, 0);
}

tree::TerminalNode* GoParser::ContinueStmtContext::IDENTIFIER() {
  return getToken(GoParser::IDENTIFIER, 0);
}


size_t GoParser::ContinueStmtContext::getRuleIndex() const {
  return GoParser::RuleContinueStmt;
}


std::any GoParser::ContinueStmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitContinueStmt(this);
  else
    return visitor->visitChildren(this);
}

GoParser::ContinueStmtContext* GoParser::continueStmt() {
  ContinueStmtContext *_localctx = _tracker.createInstance<ContinueStmtContext>(_ctx, getState());
  enterRule(_localctx, 72, GoParser::RuleContinueStmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(475);
    match(GoParser::CONTINUE);
    setState(477);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 38, _ctx)) {
    case 1: {
      setState(476);
      match(GoParser::IDENTIFIER);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GotoStmtContext ------------------------------------------------------------------

GoParser::GotoStmtContext::GotoStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GoParser::GotoStmtContext::GOTO() {
  return getToken(GoParser::GOTO, 0);
}

tree::TerminalNode* GoParser::GotoStmtContext::IDENTIFIER() {
  return getToken(GoParser::IDENTIFIER, 0);
}


size_t GoParser::GotoStmtContext::getRuleIndex() const {
  return GoParser::RuleGotoStmt;
}


std::any GoParser::GotoStmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitGotoStmt(this);
  else
    return visitor->visitChildren(this);
}

GoParser::GotoStmtContext* GoParser::gotoStmt() {
  GotoStmtContext *_localctx = _tracker.createInstance<GotoStmtContext>(_ctx, getState());
  enterRule(_localctx, 74, GoParser::RuleGotoStmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(479);
    match(GoParser::GOTO);
    setState(480);
    match(GoParser::IDENTIFIER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FallthroughStmtContext ------------------------------------------------------------------

GoParser::FallthroughStmtContext::FallthroughStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GoParser::FallthroughStmtContext::FALLTHROUGH() {
  return getToken(GoParser::FALLTHROUGH, 0);
}


size_t GoParser::FallthroughStmtContext::getRuleIndex() const {
  return GoParser::RuleFallthroughStmt;
}


std::any GoParser::FallthroughStmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitFallthroughStmt(this);
  else
    return visitor->visitChildren(this);
}

GoParser::FallthroughStmtContext* GoParser::fallthroughStmt() {
  FallthroughStmtContext *_localctx = _tracker.createInstance<FallthroughStmtContext>(_ctx, getState());
  enterRule(_localctx, 76, GoParser::RuleFallthroughStmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(482);
    match(GoParser::FALLTHROUGH);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DeferStmtContext ------------------------------------------------------------------

GoParser::DeferStmtContext::DeferStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GoParser::DeferStmtContext::DEFER() {
  return getToken(GoParser::DEFER, 0);
}

GoParser::ExpressionContext* GoParser::DeferStmtContext::expression() {
  return getRuleContext<GoParser::ExpressionContext>(0);
}


size_t GoParser::DeferStmtContext::getRuleIndex() const {
  return GoParser::RuleDeferStmt;
}


std::any GoParser::DeferStmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitDeferStmt(this);
  else
    return visitor->visitChildren(this);
}

GoParser::DeferStmtContext* GoParser::deferStmt() {
  DeferStmtContext *_localctx = _tracker.createInstance<DeferStmtContext>(_ctx, getState());
  enterRule(_localctx, 78, GoParser::RuleDeferStmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(484);
    match(GoParser::DEFER);
    setState(485);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IfStmtContext ------------------------------------------------------------------

GoParser::IfStmtContext::IfStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GoParser::IfStmtContext::IF() {
  return getToken(GoParser::IF, 0);
}

std::vector<GoParser::BlockContext *> GoParser::IfStmtContext::block() {
  return getRuleContexts<GoParser::BlockContext>();
}

GoParser::BlockContext* GoParser::IfStmtContext::block(size_t i) {
  return getRuleContext<GoParser::BlockContext>(i);
}

GoParser::ExpressionContext* GoParser::IfStmtContext::expression() {
  return getRuleContext<GoParser::ExpressionContext>(0);
}

GoParser::EosContext* GoParser::IfStmtContext::eos() {
  return getRuleContext<GoParser::EosContext>(0);
}

GoParser::SimpleStmtContext* GoParser::IfStmtContext::simpleStmt() {
  return getRuleContext<GoParser::SimpleStmtContext>(0);
}

tree::TerminalNode* GoParser::IfStmtContext::ELSE() {
  return getToken(GoParser::ELSE, 0);
}

GoParser::IfStmtContext* GoParser::IfStmtContext::ifStmt() {
  return getRuleContext<GoParser::IfStmtContext>(0);
}


size_t GoParser::IfStmtContext::getRuleIndex() const {
  return GoParser::RuleIfStmt;
}


std::any GoParser::IfStmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitIfStmt(this);
  else
    return visitor->visitChildren(this);
}

GoParser::IfStmtContext* GoParser::ifStmt() {
  IfStmtContext *_localctx = _tracker.createInstance<IfStmtContext>(_ctx, getState());
  enterRule(_localctx, 80, GoParser::RuleIfStmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(487);
    match(GoParser::IF);
    setState(496);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 39, _ctx)) {
    case 1: {
      setState(488);
      expression(0);
      break;
    }

    case 2: {
      setState(489);
      eos();
      setState(490);
      expression(0);
      break;
    }

    case 3: {
      setState(492);
      simpleStmt();
      setState(493);
      eos();
      setState(494);
      expression(0);
      break;
    }

    default:
      break;
    }
    setState(498);
    block();
    setState(504);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 41, _ctx)) {
    case 1: {
      setState(499);
      match(GoParser::ELSE);
      setState(502);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GoParser::IF: {
          setState(500);
          ifStmt();
          break;
        }

        case GoParser::L_CURLY: {
          setState(501);
          block();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SwitchStmtContext ------------------------------------------------------------------

GoParser::SwitchStmtContext::SwitchStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GoParser::ExprSwitchStmtContext* GoParser::SwitchStmtContext::exprSwitchStmt() {
  return getRuleContext<GoParser::ExprSwitchStmtContext>(0);
}

GoParser::TypeSwitchStmtContext* GoParser::SwitchStmtContext::typeSwitchStmt() {
  return getRuleContext<GoParser::TypeSwitchStmtContext>(0);
}


size_t GoParser::SwitchStmtContext::getRuleIndex() const {
  return GoParser::RuleSwitchStmt;
}


std::any GoParser::SwitchStmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitSwitchStmt(this);
  else
    return visitor->visitChildren(this);
}

GoParser::SwitchStmtContext* GoParser::switchStmt() {
  SwitchStmtContext *_localctx = _tracker.createInstance<SwitchStmtContext>(_ctx, getState());
  enterRule(_localctx, 82, GoParser::RuleSwitchStmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(508);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 42, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(506);
      exprSwitchStmt();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(507);
      typeSwitchStmt();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExprSwitchStmtContext ------------------------------------------------------------------

GoParser::ExprSwitchStmtContext::ExprSwitchStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GoParser::ExprSwitchStmtContext::SWITCH() {
  return getToken(GoParser::SWITCH, 0);
}

tree::TerminalNode* GoParser::ExprSwitchStmtContext::L_CURLY() {
  return getToken(GoParser::L_CURLY, 0);
}

tree::TerminalNode* GoParser::ExprSwitchStmtContext::R_CURLY() {
  return getToken(GoParser::R_CURLY, 0);
}

GoParser::EosContext* GoParser::ExprSwitchStmtContext::eos() {
  return getRuleContext<GoParser::EosContext>(0);
}

std::vector<GoParser::ExprCaseClauseContext *> GoParser::ExprSwitchStmtContext::exprCaseClause() {
  return getRuleContexts<GoParser::ExprCaseClauseContext>();
}

GoParser::ExprCaseClauseContext* GoParser::ExprSwitchStmtContext::exprCaseClause(size_t i) {
  return getRuleContext<GoParser::ExprCaseClauseContext>(i);
}

GoParser::ExpressionContext* GoParser::ExprSwitchStmtContext::expression() {
  return getRuleContext<GoParser::ExpressionContext>(0);
}

GoParser::SimpleStmtContext* GoParser::ExprSwitchStmtContext::simpleStmt() {
  return getRuleContext<GoParser::SimpleStmtContext>(0);
}


size_t GoParser::ExprSwitchStmtContext::getRuleIndex() const {
  return GoParser::RuleExprSwitchStmt;
}


std::any GoParser::ExprSwitchStmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitExprSwitchStmt(this);
  else
    return visitor->visitChildren(this);
}

GoParser::ExprSwitchStmtContext* GoParser::exprSwitchStmt() {
  ExprSwitchStmtContext *_localctx = _tracker.createInstance<ExprSwitchStmtContext>(_ctx, getState());
  enterRule(_localctx, 84, GoParser::RuleExprSwitchStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(510);
    match(GoParser::SWITCH);
    setState(521);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 46, _ctx)) {
    case 1: {
      setState(512);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & -288230371386978792) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & 99135) != 0)) {
        setState(511);
        expression(0);
      }
      break;
    }

    case 2: {
      setState(515);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 44, _ctx)) {
      case 1: {
        setState(514);
        simpleStmt();
        break;
      }

      default:
        break;
      }
      setState(517);
      eos();
      setState(519);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & -288230371386978792) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & 99135) != 0)) {
        setState(518);
        expression(0);
      }
      break;
    }

    default:
      break;
    }
    setState(523);
    match(GoParser::L_CURLY);
    setState(527);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == GoParser::DEFAULT

    || _la == GoParser::CASE) {
      setState(524);
      exprCaseClause();
      setState(529);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(530);
    match(GoParser::R_CURLY);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExprCaseClauseContext ------------------------------------------------------------------

GoParser::ExprCaseClauseContext::ExprCaseClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GoParser::ExprSwitchCaseContext* GoParser::ExprCaseClauseContext::exprSwitchCase() {
  return getRuleContext<GoParser::ExprSwitchCaseContext>(0);
}

tree::TerminalNode* GoParser::ExprCaseClauseContext::COLON() {
  return getToken(GoParser::COLON, 0);
}

GoParser::StatementListContext* GoParser::ExprCaseClauseContext::statementList() {
  return getRuleContext<GoParser::StatementListContext>(0);
}


size_t GoParser::ExprCaseClauseContext::getRuleIndex() const {
  return GoParser::RuleExprCaseClause;
}


std::any GoParser::ExprCaseClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitExprCaseClause(this);
  else
    return visitor->visitChildren(this);
}

GoParser::ExprCaseClauseContext* GoParser::exprCaseClause() {
  ExprCaseClauseContext *_localctx = _tracker.createInstance<ExprCaseClauseContext>(_ctx, getState());
  enterRule(_localctx, 86, GoParser::RuleExprCaseClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(532);
    exprSwitchCase();
    setState(533);
    match(GoParser::COLON);
    setState(535);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 48, _ctx)) {
    case 1: {
      setState(534);
      statementList();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExprSwitchCaseContext ------------------------------------------------------------------

GoParser::ExprSwitchCaseContext::ExprSwitchCaseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GoParser::ExprSwitchCaseContext::CASE() {
  return getToken(GoParser::CASE, 0);
}

GoParser::ExpressionListContext* GoParser::ExprSwitchCaseContext::expressionList() {
  return getRuleContext<GoParser::ExpressionListContext>(0);
}

tree::TerminalNode* GoParser::ExprSwitchCaseContext::DEFAULT() {
  return getToken(GoParser::DEFAULT, 0);
}


size_t GoParser::ExprSwitchCaseContext::getRuleIndex() const {
  return GoParser::RuleExprSwitchCase;
}


std::any GoParser::ExprSwitchCaseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitExprSwitchCase(this);
  else
    return visitor->visitChildren(this);
}

GoParser::ExprSwitchCaseContext* GoParser::exprSwitchCase() {
  ExprSwitchCaseContext *_localctx = _tracker.createInstance<ExprSwitchCaseContext>(_ctx, getState());
  enterRule(_localctx, 88, GoParser::RuleExprSwitchCase);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(540);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GoParser::CASE: {
        enterOuterAlt(_localctx, 1);
        setState(537);
        match(GoParser::CASE);
        setState(538);
        expressionList();
        break;
      }

      case GoParser::DEFAULT: {
        enterOuterAlt(_localctx, 2);
        setState(539);
        match(GoParser::DEFAULT);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeSwitchStmtContext ------------------------------------------------------------------

GoParser::TypeSwitchStmtContext::TypeSwitchStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GoParser::TypeSwitchStmtContext::SWITCH() {
  return getToken(GoParser::SWITCH, 0);
}

tree::TerminalNode* GoParser::TypeSwitchStmtContext::L_CURLY() {
  return getToken(GoParser::L_CURLY, 0);
}

tree::TerminalNode* GoParser::TypeSwitchStmtContext::R_CURLY() {
  return getToken(GoParser::R_CURLY, 0);
}

GoParser::TypeSwitchGuardContext* GoParser::TypeSwitchStmtContext::typeSwitchGuard() {
  return getRuleContext<GoParser::TypeSwitchGuardContext>(0);
}

GoParser::EosContext* GoParser::TypeSwitchStmtContext::eos() {
  return getRuleContext<GoParser::EosContext>(0);
}

GoParser::SimpleStmtContext* GoParser::TypeSwitchStmtContext::simpleStmt() {
  return getRuleContext<GoParser::SimpleStmtContext>(0);
}

std::vector<GoParser::TypeCaseClauseContext *> GoParser::TypeSwitchStmtContext::typeCaseClause() {
  return getRuleContexts<GoParser::TypeCaseClauseContext>();
}

GoParser::TypeCaseClauseContext* GoParser::TypeSwitchStmtContext::typeCaseClause(size_t i) {
  return getRuleContext<GoParser::TypeCaseClauseContext>(i);
}


size_t GoParser::TypeSwitchStmtContext::getRuleIndex() const {
  return GoParser::RuleTypeSwitchStmt;
}


std::any GoParser::TypeSwitchStmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitTypeSwitchStmt(this);
  else
    return visitor->visitChildren(this);
}

GoParser::TypeSwitchStmtContext* GoParser::typeSwitchStmt() {
  TypeSwitchStmtContext *_localctx = _tracker.createInstance<TypeSwitchStmtContext>(_ctx, getState());
  enterRule(_localctx, 90, GoParser::RuleTypeSwitchStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(542);
    match(GoParser::SWITCH);
    setState(551);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 50, _ctx)) {
    case 1: {
      setState(543);
      typeSwitchGuard();
      break;
    }

    case 2: {
      setState(544);
      eos();
      setState(545);
      typeSwitchGuard();
      break;
    }

    case 3: {
      setState(547);
      simpleStmt();
      setState(548);
      eos();
      setState(549);
      typeSwitchGuard();
      break;
    }

    default:
      break;
    }
    setState(553);
    match(GoParser::L_CURLY);
    setState(557);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == GoParser::DEFAULT

    || _la == GoParser::CASE) {
      setState(554);
      typeCaseClause();
      setState(559);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(560);
    match(GoParser::R_CURLY);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeSwitchGuardContext ------------------------------------------------------------------

GoParser::TypeSwitchGuardContext::TypeSwitchGuardContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GoParser::PrimaryExprContext* GoParser::TypeSwitchGuardContext::primaryExpr() {
  return getRuleContext<GoParser::PrimaryExprContext>(0);
}

tree::TerminalNode* GoParser::TypeSwitchGuardContext::DOT() {
  return getToken(GoParser::DOT, 0);
}

tree::TerminalNode* GoParser::TypeSwitchGuardContext::L_PAREN() {
  return getToken(GoParser::L_PAREN, 0);
}

tree::TerminalNode* GoParser::TypeSwitchGuardContext::TYPE() {
  return getToken(GoParser::TYPE, 0);
}

tree::TerminalNode* GoParser::TypeSwitchGuardContext::R_PAREN() {
  return getToken(GoParser::R_PAREN, 0);
}

tree::TerminalNode* GoParser::TypeSwitchGuardContext::IDENTIFIER() {
  return getToken(GoParser::IDENTIFIER, 0);
}

tree::TerminalNode* GoParser::TypeSwitchGuardContext::DECLARE_ASSIGN() {
  return getToken(GoParser::DECLARE_ASSIGN, 0);
}


size_t GoParser::TypeSwitchGuardContext::getRuleIndex() const {
  return GoParser::RuleTypeSwitchGuard;
}


std::any GoParser::TypeSwitchGuardContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitTypeSwitchGuard(this);
  else
    return visitor->visitChildren(this);
}

GoParser::TypeSwitchGuardContext* GoParser::typeSwitchGuard() {
  TypeSwitchGuardContext *_localctx = _tracker.createInstance<TypeSwitchGuardContext>(_ctx, getState());
  enterRule(_localctx, 92, GoParser::RuleTypeSwitchGuard);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(564);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 52, _ctx)) {
    case 1: {
      setState(562);
      match(GoParser::IDENTIFIER);
      setState(563);
      match(GoParser::DECLARE_ASSIGN);
      break;
    }

    default:
      break;
    }
    setState(566);
    primaryExpr(0);
    setState(567);
    match(GoParser::DOT);
    setState(568);
    match(GoParser::L_PAREN);
    setState(569);
    match(GoParser::TYPE);
    setState(570);
    match(GoParser::R_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeCaseClauseContext ------------------------------------------------------------------

GoParser::TypeCaseClauseContext::TypeCaseClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GoParser::TypeSwitchCaseContext* GoParser::TypeCaseClauseContext::typeSwitchCase() {
  return getRuleContext<GoParser::TypeSwitchCaseContext>(0);
}

tree::TerminalNode* GoParser::TypeCaseClauseContext::COLON() {
  return getToken(GoParser::COLON, 0);
}

GoParser::StatementListContext* GoParser::TypeCaseClauseContext::statementList() {
  return getRuleContext<GoParser::StatementListContext>(0);
}


size_t GoParser::TypeCaseClauseContext::getRuleIndex() const {
  return GoParser::RuleTypeCaseClause;
}


std::any GoParser::TypeCaseClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitTypeCaseClause(this);
  else
    return visitor->visitChildren(this);
}

GoParser::TypeCaseClauseContext* GoParser::typeCaseClause() {
  TypeCaseClauseContext *_localctx = _tracker.createInstance<TypeCaseClauseContext>(_ctx, getState());
  enterRule(_localctx, 94, GoParser::RuleTypeCaseClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(572);
    typeSwitchCase();
    setState(573);
    match(GoParser::COLON);
    setState(575);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 53, _ctx)) {
    case 1: {
      setState(574);
      statementList();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeSwitchCaseContext ------------------------------------------------------------------

GoParser::TypeSwitchCaseContext::TypeSwitchCaseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GoParser::TypeSwitchCaseContext::CASE() {
  return getToken(GoParser::CASE, 0);
}

GoParser::TypeListContext* GoParser::TypeSwitchCaseContext::typeList() {
  return getRuleContext<GoParser::TypeListContext>(0);
}

tree::TerminalNode* GoParser::TypeSwitchCaseContext::DEFAULT() {
  return getToken(GoParser::DEFAULT, 0);
}


size_t GoParser::TypeSwitchCaseContext::getRuleIndex() const {
  return GoParser::RuleTypeSwitchCase;
}


std::any GoParser::TypeSwitchCaseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitTypeSwitchCase(this);
  else
    return visitor->visitChildren(this);
}

GoParser::TypeSwitchCaseContext* GoParser::typeSwitchCase() {
  TypeSwitchCaseContext *_localctx = _tracker.createInstance<TypeSwitchCaseContext>(_ctx, getState());
  enterRule(_localctx, 96, GoParser::RuleTypeSwitchCase);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(580);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GoParser::CASE: {
        enterOuterAlt(_localctx, 1);
        setState(577);
        match(GoParser::CASE);
        setState(578);
        typeList();
        break;
      }

      case GoParser::DEFAULT: {
        enterOuterAlt(_localctx, 2);
        setState(579);
        match(GoParser::DEFAULT);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeListContext ------------------------------------------------------------------

GoParser::TypeListContext::TypeListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GoParser::Type_Context *> GoParser::TypeListContext::type_() {
  return getRuleContexts<GoParser::Type_Context>();
}

GoParser::Type_Context* GoParser::TypeListContext::type_(size_t i) {
  return getRuleContext<GoParser::Type_Context>(i);
}

std::vector<tree::TerminalNode *> GoParser::TypeListContext::NIL_LIT() {
  return getTokens(GoParser::NIL_LIT);
}

tree::TerminalNode* GoParser::TypeListContext::NIL_LIT(size_t i) {
  return getToken(GoParser::NIL_LIT, i);
}

std::vector<tree::TerminalNode *> GoParser::TypeListContext::COMMA() {
  return getTokens(GoParser::COMMA);
}

tree::TerminalNode* GoParser::TypeListContext::COMMA(size_t i) {
  return getToken(GoParser::COMMA, i);
}


size_t GoParser::TypeListContext::getRuleIndex() const {
  return GoParser::RuleTypeList;
}


std::any GoParser::TypeListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitTypeList(this);
  else
    return visitor->visitChildren(this);
}

GoParser::TypeListContext* GoParser::typeList() {
  TypeListContext *_localctx = _tracker.createInstance<TypeListContext>(_ctx, getState());
  enterRule(_localctx, 98, GoParser::RuleTypeList);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(584);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GoParser::FUNC:
      case GoParser::INTERFACE:
      case GoParser::MAP:
      case GoParser::STRUCT:
      case GoParser::CHAN:
      case GoParser::IDENTIFIER:
      case GoParser::L_PAREN:
      case GoParser::L_BRACKET:
      case GoParser::STAR:
      case GoParser::RECEIVE: {
        setState(582);
        type_();
        break;
      }

      case GoParser::NIL_LIT: {
        setState(583);
        match(GoParser::NIL_LIT);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(593);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 57, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(586);
        match(GoParser::COMMA);
        setState(589);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case GoParser::FUNC:
          case GoParser::INTERFACE:
          case GoParser::MAP:
          case GoParser::STRUCT:
          case GoParser::CHAN:
          case GoParser::IDENTIFIER:
          case GoParser::L_PAREN:
          case GoParser::L_BRACKET:
          case GoParser::STAR:
          case GoParser::RECEIVE: {
            setState(587);
            type_();
            break;
          }

          case GoParser::NIL_LIT: {
            setState(588);
            match(GoParser::NIL_LIT);
            break;
          }

        default:
          throw NoViableAltException(this);
        } 
      }
      setState(595);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 57, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SelectStmtContext ------------------------------------------------------------------

GoParser::SelectStmtContext::SelectStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GoParser::SelectStmtContext::SELECT() {
  return getToken(GoParser::SELECT, 0);
}

tree::TerminalNode* GoParser::SelectStmtContext::L_CURLY() {
  return getToken(GoParser::L_CURLY, 0);
}

tree::TerminalNode* GoParser::SelectStmtContext::R_CURLY() {
  return getToken(GoParser::R_CURLY, 0);
}

std::vector<GoParser::CommClauseContext *> GoParser::SelectStmtContext::commClause() {
  return getRuleContexts<GoParser::CommClauseContext>();
}

GoParser::CommClauseContext* GoParser::SelectStmtContext::commClause(size_t i) {
  return getRuleContext<GoParser::CommClauseContext>(i);
}


size_t GoParser::SelectStmtContext::getRuleIndex() const {
  return GoParser::RuleSelectStmt;
}


std::any GoParser::SelectStmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitSelectStmt(this);
  else
    return visitor->visitChildren(this);
}

GoParser::SelectStmtContext* GoParser::selectStmt() {
  SelectStmtContext *_localctx = _tracker.createInstance<SelectStmtContext>(_ctx, getState());
  enterRule(_localctx, 100, GoParser::RuleSelectStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(596);
    match(GoParser::SELECT);
    setState(597);
    match(GoParser::L_CURLY);
    setState(601);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == GoParser::DEFAULT

    || _la == GoParser::CASE) {
      setState(598);
      commClause();
      setState(603);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(604);
    match(GoParser::R_CURLY);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CommClauseContext ------------------------------------------------------------------

GoParser::CommClauseContext::CommClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GoParser::CommCaseContext* GoParser::CommClauseContext::commCase() {
  return getRuleContext<GoParser::CommCaseContext>(0);
}

tree::TerminalNode* GoParser::CommClauseContext::COLON() {
  return getToken(GoParser::COLON, 0);
}

GoParser::StatementListContext* GoParser::CommClauseContext::statementList() {
  return getRuleContext<GoParser::StatementListContext>(0);
}


size_t GoParser::CommClauseContext::getRuleIndex() const {
  return GoParser::RuleCommClause;
}


std::any GoParser::CommClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitCommClause(this);
  else
    return visitor->visitChildren(this);
}

GoParser::CommClauseContext* GoParser::commClause() {
  CommClauseContext *_localctx = _tracker.createInstance<CommClauseContext>(_ctx, getState());
  enterRule(_localctx, 102, GoParser::RuleCommClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(606);
    commCase();
    setState(607);
    match(GoParser::COLON);
    setState(609);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 59, _ctx)) {
    case 1: {
      setState(608);
      statementList();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CommCaseContext ------------------------------------------------------------------

GoParser::CommCaseContext::CommCaseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GoParser::CommCaseContext::CASE() {
  return getToken(GoParser::CASE, 0);
}

GoParser::SendStmtContext* GoParser::CommCaseContext::sendStmt() {
  return getRuleContext<GoParser::SendStmtContext>(0);
}

GoParser::RecvStmtContext* GoParser::CommCaseContext::recvStmt() {
  return getRuleContext<GoParser::RecvStmtContext>(0);
}

tree::TerminalNode* GoParser::CommCaseContext::DEFAULT() {
  return getToken(GoParser::DEFAULT, 0);
}


size_t GoParser::CommCaseContext::getRuleIndex() const {
  return GoParser::RuleCommCase;
}


std::any GoParser::CommCaseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitCommCase(this);
  else
    return visitor->visitChildren(this);
}

GoParser::CommCaseContext* GoParser::commCase() {
  CommCaseContext *_localctx = _tracker.createInstance<CommCaseContext>(_ctx, getState());
  enterRule(_localctx, 104, GoParser::RuleCommCase);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(617);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GoParser::CASE: {
        enterOuterAlt(_localctx, 1);
        setState(611);
        match(GoParser::CASE);
        setState(614);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 60, _ctx)) {
        case 1: {
          setState(612);
          sendStmt();
          break;
        }

        case 2: {
          setState(613);
          recvStmt();
          break;
        }

        default:
          break;
        }
        break;
      }

      case GoParser::DEFAULT: {
        enterOuterAlt(_localctx, 2);
        setState(616);
        match(GoParser::DEFAULT);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RecvStmtContext ------------------------------------------------------------------

GoParser::RecvStmtContext::RecvStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GoParser::ExpressionContext* GoParser::RecvStmtContext::expression() {
  return getRuleContext<GoParser::ExpressionContext>(0);
}

GoParser::ExpressionListContext* GoParser::RecvStmtContext::expressionList() {
  return getRuleContext<GoParser::ExpressionListContext>(0);
}

tree::TerminalNode* GoParser::RecvStmtContext::ASSIGN() {
  return getToken(GoParser::ASSIGN, 0);
}

GoParser::IdentifierListContext* GoParser::RecvStmtContext::identifierList() {
  return getRuleContext<GoParser::IdentifierListContext>(0);
}

tree::TerminalNode* GoParser::RecvStmtContext::DECLARE_ASSIGN() {
  return getToken(GoParser::DECLARE_ASSIGN, 0);
}


size_t GoParser::RecvStmtContext::getRuleIndex() const {
  return GoParser::RuleRecvStmt;
}


std::any GoParser::RecvStmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitRecvStmt(this);
  else
    return visitor->visitChildren(this);
}

GoParser::RecvStmtContext* GoParser::recvStmt() {
  RecvStmtContext *_localctx = _tracker.createInstance<RecvStmtContext>(_ctx, getState());
  enterRule(_localctx, 106, GoParser::RuleRecvStmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(625);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 62, _ctx)) {
    case 1: {
      setState(619);
      expressionList();
      setState(620);
      match(GoParser::ASSIGN);
      break;
    }

    case 2: {
      setState(622);
      identifierList();
      setState(623);
      match(GoParser::DECLARE_ASSIGN);
      break;
    }

    default:
      break;
    }
    setState(627);
    antlrcpp::downCast<RecvStmtContext *>(_localctx)->recvExpr = expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ForStmtContext ------------------------------------------------------------------

GoParser::ForStmtContext::ForStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GoParser::ForStmtContext::FOR() {
  return getToken(GoParser::FOR, 0);
}

GoParser::BlockContext* GoParser::ForStmtContext::block() {
  return getRuleContext<GoParser::BlockContext>(0);
}

GoParser::ForClauseContext* GoParser::ForStmtContext::forClause() {
  return getRuleContext<GoParser::ForClauseContext>(0);
}

GoParser::ExpressionContext* GoParser::ForStmtContext::expression() {
  return getRuleContext<GoParser::ExpressionContext>(0);
}

GoParser::RangeClauseContext* GoParser::ForStmtContext::rangeClause() {
  return getRuleContext<GoParser::RangeClauseContext>(0);
}


size_t GoParser::ForStmtContext::getRuleIndex() const {
  return GoParser::RuleForStmt;
}


std::any GoParser::ForStmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitForStmt(this);
  else
    return visitor->visitChildren(this);
}

GoParser::ForStmtContext* GoParser::forStmt() {
  ForStmtContext *_localctx = _tracker.createInstance<ForStmtContext>(_ctx, getState());
  enterRule(_localctx, 108, GoParser::RuleForStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(629);
    match(GoParser::FOR);
    setState(637);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 65, _ctx)) {
    case 1: {
      setState(631);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & -288230371386978792) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & 99135) != 0)) {
        setState(630);
        expression(0);
      }
      break;
    }

    case 2: {
      setState(633);
      forClause();
      break;
    }

    case 3: {
      setState(635);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & -288230371386454504) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & 99135) != 0)) {
        setState(634);
        rangeClause();
      }
      break;
    }

    default:
      break;
    }
    setState(639);
    block();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ForClauseContext ------------------------------------------------------------------

GoParser::ForClauseContext::ForClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GoParser::EosContext *> GoParser::ForClauseContext::eos() {
  return getRuleContexts<GoParser::EosContext>();
}

GoParser::EosContext* GoParser::ForClauseContext::eos(size_t i) {
  return getRuleContext<GoParser::EosContext>(i);
}

GoParser::ExpressionContext* GoParser::ForClauseContext::expression() {
  return getRuleContext<GoParser::ExpressionContext>(0);
}

std::vector<GoParser::SimpleStmtContext *> GoParser::ForClauseContext::simpleStmt() {
  return getRuleContexts<GoParser::SimpleStmtContext>();
}

GoParser::SimpleStmtContext* GoParser::ForClauseContext::simpleStmt(size_t i) {
  return getRuleContext<GoParser::SimpleStmtContext>(i);
}


size_t GoParser::ForClauseContext::getRuleIndex() const {
  return GoParser::RuleForClause;
}


std::any GoParser::ForClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitForClause(this);
  else
    return visitor->visitChildren(this);
}

GoParser::ForClauseContext* GoParser::forClause() {
  ForClauseContext *_localctx = _tracker.createInstance<ForClauseContext>(_ctx, getState());
  enterRule(_localctx, 110, GoParser::RuleForClause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(642);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 66, _ctx)) {
    case 1: {
      setState(641);
      antlrcpp::downCast<ForClauseContext *>(_localctx)->initStmt = simpleStmt();
      break;
    }

    default:
      break;
    }
    setState(644);
    eos();
    setState(646);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 67, _ctx)) {
    case 1: {
      setState(645);
      expression(0);
      break;
    }

    default:
      break;
    }
    setState(648);
    eos();
    setState(650);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -288230371386978792) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 99135) != 0)) {
      setState(649);
      antlrcpp::downCast<ForClauseContext *>(_localctx)->postStmt = simpleStmt();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RangeClauseContext ------------------------------------------------------------------

GoParser::RangeClauseContext::RangeClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GoParser::RangeClauseContext::RANGE() {
  return getToken(GoParser::RANGE, 0);
}

GoParser::ExpressionContext* GoParser::RangeClauseContext::expression() {
  return getRuleContext<GoParser::ExpressionContext>(0);
}

GoParser::ExpressionListContext* GoParser::RangeClauseContext::expressionList() {
  return getRuleContext<GoParser::ExpressionListContext>(0);
}

tree::TerminalNode* GoParser::RangeClauseContext::ASSIGN() {
  return getToken(GoParser::ASSIGN, 0);
}

GoParser::IdentifierListContext* GoParser::RangeClauseContext::identifierList() {
  return getRuleContext<GoParser::IdentifierListContext>(0);
}

tree::TerminalNode* GoParser::RangeClauseContext::DECLARE_ASSIGN() {
  return getToken(GoParser::DECLARE_ASSIGN, 0);
}


size_t GoParser::RangeClauseContext::getRuleIndex() const {
  return GoParser::RuleRangeClause;
}


std::any GoParser::RangeClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitRangeClause(this);
  else
    return visitor->visitChildren(this);
}

GoParser::RangeClauseContext* GoParser::rangeClause() {
  RangeClauseContext *_localctx = _tracker.createInstance<RangeClauseContext>(_ctx, getState());
  enterRule(_localctx, 112, GoParser::RuleRangeClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(658);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 69, _ctx)) {
    case 1: {
      setState(652);
      expressionList();
      setState(653);
      match(GoParser::ASSIGN);
      break;
    }

    case 2: {
      setState(655);
      identifierList();
      setState(656);
      match(GoParser::DECLARE_ASSIGN);
      break;
    }

    default:
      break;
    }
    setState(660);
    match(GoParser::RANGE);
    setState(661);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GoStmtContext ------------------------------------------------------------------

GoParser::GoStmtContext::GoStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GoParser::GoStmtContext::GO() {
  return getToken(GoParser::GO, 0);
}

GoParser::ExpressionContext* GoParser::GoStmtContext::expression() {
  return getRuleContext<GoParser::ExpressionContext>(0);
}


size_t GoParser::GoStmtContext::getRuleIndex() const {
  return GoParser::RuleGoStmt;
}


std::any GoParser::GoStmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitGoStmt(this);
  else
    return visitor->visitChildren(this);
}

GoParser::GoStmtContext* GoParser::goStmt() {
  GoStmtContext *_localctx = _tracker.createInstance<GoStmtContext>(_ctx, getState());
  enterRule(_localctx, 114, GoParser::RuleGoStmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(663);
    match(GoParser::GO);
    setState(664);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Type_Context ------------------------------------------------------------------

GoParser::Type_Context::Type_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GoParser::TypeNameContext* GoParser::Type_Context::typeName() {
  return getRuleContext<GoParser::TypeNameContext>(0);
}

GoParser::TypeArgsContext* GoParser::Type_Context::typeArgs() {
  return getRuleContext<GoParser::TypeArgsContext>(0);
}

GoParser::TypeLitContext* GoParser::Type_Context::typeLit() {
  return getRuleContext<GoParser::TypeLitContext>(0);
}

tree::TerminalNode* GoParser::Type_Context::L_PAREN() {
  return getToken(GoParser::L_PAREN, 0);
}

GoParser::Type_Context* GoParser::Type_Context::type_() {
  return getRuleContext<GoParser::Type_Context>(0);
}

tree::TerminalNode* GoParser::Type_Context::R_PAREN() {
  return getToken(GoParser::R_PAREN, 0);
}


size_t GoParser::Type_Context::getRuleIndex() const {
  return GoParser::RuleType_;
}


std::any GoParser::Type_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitType_(this);
  else
    return visitor->visitChildren(this);
}

GoParser::Type_Context* GoParser::type_() {
  Type_Context *_localctx = _tracker.createInstance<Type_Context>(_ctx, getState());
  enterRule(_localctx, 116, GoParser::RuleType_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(675);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GoParser::IDENTIFIER: {
        enterOuterAlt(_localctx, 1);
        setState(666);
        typeName();
        setState(668);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 70, _ctx)) {
        case 1: {
          setState(667);
          typeArgs();
          break;
        }

        default:
          break;
        }
        break;
      }

      case GoParser::FUNC:
      case GoParser::INTERFACE:
      case GoParser::MAP:
      case GoParser::STRUCT:
      case GoParser::CHAN:
      case GoParser::L_BRACKET:
      case GoParser::STAR:
      case GoParser::RECEIVE: {
        enterOuterAlt(_localctx, 2);
        setState(670);
        typeLit();
        break;
      }

      case GoParser::L_PAREN: {
        enterOuterAlt(_localctx, 3);
        setState(671);
        match(GoParser::L_PAREN);
        setState(672);
        type_();
        setState(673);
        match(GoParser::R_PAREN);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeArgsContext ------------------------------------------------------------------

GoParser::TypeArgsContext::TypeArgsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GoParser::TypeArgsContext::L_BRACKET() {
  return getToken(GoParser::L_BRACKET, 0);
}

GoParser::TypeListContext* GoParser::TypeArgsContext::typeList() {
  return getRuleContext<GoParser::TypeListContext>(0);
}

tree::TerminalNode* GoParser::TypeArgsContext::R_BRACKET() {
  return getToken(GoParser::R_BRACKET, 0);
}

tree::TerminalNode* GoParser::TypeArgsContext::COMMA() {
  return getToken(GoParser::COMMA, 0);
}


size_t GoParser::TypeArgsContext::getRuleIndex() const {
  return GoParser::RuleTypeArgs;
}


std::any GoParser::TypeArgsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitTypeArgs(this);
  else
    return visitor->visitChildren(this);
}

GoParser::TypeArgsContext* GoParser::typeArgs() {
  TypeArgsContext *_localctx = _tracker.createInstance<TypeArgsContext>(_ctx, getState());
  enterRule(_localctx, 118, GoParser::RuleTypeArgs);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(677);
    match(GoParser::L_BRACKET);
    setState(678);
    typeList();
    setState(680);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GoParser::COMMA) {
      setState(679);
      match(GoParser::COMMA);
    }
    setState(682);
    match(GoParser::R_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeNameContext ------------------------------------------------------------------

GoParser::TypeNameContext::TypeNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GoParser::QualifiedIdentContext* GoParser::TypeNameContext::qualifiedIdent() {
  return getRuleContext<GoParser::QualifiedIdentContext>(0);
}

tree::TerminalNode* GoParser::TypeNameContext::IDENTIFIER() {
  return getToken(GoParser::IDENTIFIER, 0);
}


size_t GoParser::TypeNameContext::getRuleIndex() const {
  return GoParser::RuleTypeName;
}


std::any GoParser::TypeNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitTypeName(this);
  else
    return visitor->visitChildren(this);
}

GoParser::TypeNameContext* GoParser::typeName() {
  TypeNameContext *_localctx = _tracker.createInstance<TypeNameContext>(_ctx, getState());
  enterRule(_localctx, 120, GoParser::RuleTypeName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(686);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 73, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(684);
      qualifiedIdent();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(685);
      match(GoParser::IDENTIFIER);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeLitContext ------------------------------------------------------------------

GoParser::TypeLitContext::TypeLitContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GoParser::ArrayTypeContext* GoParser::TypeLitContext::arrayType() {
  return getRuleContext<GoParser::ArrayTypeContext>(0);
}

GoParser::StructTypeContext* GoParser::TypeLitContext::structType() {
  return getRuleContext<GoParser::StructTypeContext>(0);
}

GoParser::PointerTypeContext* GoParser::TypeLitContext::pointerType() {
  return getRuleContext<GoParser::PointerTypeContext>(0);
}

GoParser::FunctionTypeContext* GoParser::TypeLitContext::functionType() {
  return getRuleContext<GoParser::FunctionTypeContext>(0);
}

GoParser::InterfaceTypeContext* GoParser::TypeLitContext::interfaceType() {
  return getRuleContext<GoParser::InterfaceTypeContext>(0);
}

GoParser::SliceTypeContext* GoParser::TypeLitContext::sliceType() {
  return getRuleContext<GoParser::SliceTypeContext>(0);
}

GoParser::MapTypeContext* GoParser::TypeLitContext::mapType() {
  return getRuleContext<GoParser::MapTypeContext>(0);
}

GoParser::ChannelTypeContext* GoParser::TypeLitContext::channelType() {
  return getRuleContext<GoParser::ChannelTypeContext>(0);
}


size_t GoParser::TypeLitContext::getRuleIndex() const {
  return GoParser::RuleTypeLit;
}


std::any GoParser::TypeLitContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitTypeLit(this);
  else
    return visitor->visitChildren(this);
}

GoParser::TypeLitContext* GoParser::typeLit() {
  TypeLitContext *_localctx = _tracker.createInstance<TypeLitContext>(_ctx, getState());
  enterRule(_localctx, 122, GoParser::RuleTypeLit);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(696);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 74, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(688);
      arrayType();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(689);
      structType();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(690);
      pointerType();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(691);
      functionType();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(692);
      interfaceType();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(693);
      sliceType();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(694);
      mapType();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(695);
      channelType();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArrayTypeContext ------------------------------------------------------------------

GoParser::ArrayTypeContext::ArrayTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GoParser::ArrayTypeContext::L_BRACKET() {
  return getToken(GoParser::L_BRACKET, 0);
}

GoParser::ArrayLengthContext* GoParser::ArrayTypeContext::arrayLength() {
  return getRuleContext<GoParser::ArrayLengthContext>(0);
}

tree::TerminalNode* GoParser::ArrayTypeContext::R_BRACKET() {
  return getToken(GoParser::R_BRACKET, 0);
}

GoParser::ElementTypeContext* GoParser::ArrayTypeContext::elementType() {
  return getRuleContext<GoParser::ElementTypeContext>(0);
}


size_t GoParser::ArrayTypeContext::getRuleIndex() const {
  return GoParser::RuleArrayType;
}


std::any GoParser::ArrayTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitArrayType(this);
  else
    return visitor->visitChildren(this);
}

GoParser::ArrayTypeContext* GoParser::arrayType() {
  ArrayTypeContext *_localctx = _tracker.createInstance<ArrayTypeContext>(_ctx, getState());
  enterRule(_localctx, 124, GoParser::RuleArrayType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(698);
    match(GoParser::L_BRACKET);
    setState(699);
    arrayLength();
    setState(700);
    match(GoParser::R_BRACKET);
    setState(701);
    elementType();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArrayLengthContext ------------------------------------------------------------------

GoParser::ArrayLengthContext::ArrayLengthContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GoParser::ExpressionContext* GoParser::ArrayLengthContext::expression() {
  return getRuleContext<GoParser::ExpressionContext>(0);
}


size_t GoParser::ArrayLengthContext::getRuleIndex() const {
  return GoParser::RuleArrayLength;
}


std::any GoParser::ArrayLengthContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitArrayLength(this);
  else
    return visitor->visitChildren(this);
}

GoParser::ArrayLengthContext* GoParser::arrayLength() {
  ArrayLengthContext *_localctx = _tracker.createInstance<ArrayLengthContext>(_ctx, getState());
  enterRule(_localctx, 126, GoParser::RuleArrayLength);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(703);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ElementTypeContext ------------------------------------------------------------------

GoParser::ElementTypeContext::ElementTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GoParser::Type_Context* GoParser::ElementTypeContext::type_() {
  return getRuleContext<GoParser::Type_Context>(0);
}


size_t GoParser::ElementTypeContext::getRuleIndex() const {
  return GoParser::RuleElementType;
}


std::any GoParser::ElementTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitElementType(this);
  else
    return visitor->visitChildren(this);
}

GoParser::ElementTypeContext* GoParser::elementType() {
  ElementTypeContext *_localctx = _tracker.createInstance<ElementTypeContext>(_ctx, getState());
  enterRule(_localctx, 128, GoParser::RuleElementType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(705);
    type_();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PointerTypeContext ------------------------------------------------------------------

GoParser::PointerTypeContext::PointerTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GoParser::PointerTypeContext::STAR() {
  return getToken(GoParser::STAR, 0);
}

GoParser::Type_Context* GoParser::PointerTypeContext::type_() {
  return getRuleContext<GoParser::Type_Context>(0);
}


size_t GoParser::PointerTypeContext::getRuleIndex() const {
  return GoParser::RulePointerType;
}


std::any GoParser::PointerTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitPointerType(this);
  else
    return visitor->visitChildren(this);
}

GoParser::PointerTypeContext* GoParser::pointerType() {
  PointerTypeContext *_localctx = _tracker.createInstance<PointerTypeContext>(_ctx, getState());
  enterRule(_localctx, 130, GoParser::RulePointerType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(707);
    match(GoParser::STAR);
    setState(708);
    type_();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InterfaceTypeContext ------------------------------------------------------------------

GoParser::InterfaceTypeContext::InterfaceTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GoParser::InterfaceTypeContext::INTERFACE() {
  return getToken(GoParser::INTERFACE, 0);
}

tree::TerminalNode* GoParser::InterfaceTypeContext::L_CURLY() {
  return getToken(GoParser::L_CURLY, 0);
}

tree::TerminalNode* GoParser::InterfaceTypeContext::R_CURLY() {
  return getToken(GoParser::R_CURLY, 0);
}

std::vector<GoParser::EosContext *> GoParser::InterfaceTypeContext::eos() {
  return getRuleContexts<GoParser::EosContext>();
}

GoParser::EosContext* GoParser::InterfaceTypeContext::eos(size_t i) {
  return getRuleContext<GoParser::EosContext>(i);
}

std::vector<GoParser::MethodSpecContext *> GoParser::InterfaceTypeContext::methodSpec() {
  return getRuleContexts<GoParser::MethodSpecContext>();
}

GoParser::MethodSpecContext* GoParser::InterfaceTypeContext::methodSpec(size_t i) {
  return getRuleContext<GoParser::MethodSpecContext>(i);
}

std::vector<GoParser::TypeElementContext *> GoParser::InterfaceTypeContext::typeElement() {
  return getRuleContexts<GoParser::TypeElementContext>();
}

GoParser::TypeElementContext* GoParser::InterfaceTypeContext::typeElement(size_t i) {
  return getRuleContext<GoParser::TypeElementContext>(i);
}


size_t GoParser::InterfaceTypeContext::getRuleIndex() const {
  return GoParser::RuleInterfaceType;
}


std::any GoParser::InterfaceTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitInterfaceType(this);
  else
    return visitor->visitChildren(this);
}

GoParser::InterfaceTypeContext* GoParser::interfaceType() {
  InterfaceTypeContext *_localctx = _tracker.createInstance<InterfaceTypeContext>(_ctx, getState());
  enterRule(_localctx, 132, GoParser::RuleInterfaceType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(710);
    match(GoParser::INTERFACE);
    setState(711);
    match(GoParser::L_CURLY);
    setState(720);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((((_la - 3) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 3)) & 2900318160613802435) != 0)) {
      setState(714);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 75, _ctx)) {
      case 1: {
        setState(712);
        methodSpec();
        break;
      }

      case 2: {
        setState(713);
        typeElement();
        break;
      }

      default:
        break;
      }
      setState(716);
      eos();
      setState(722);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(723);
    match(GoParser::R_CURLY);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SliceTypeContext ------------------------------------------------------------------

GoParser::SliceTypeContext::SliceTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GoParser::SliceTypeContext::L_BRACKET() {
  return getToken(GoParser::L_BRACKET, 0);
}

tree::TerminalNode* GoParser::SliceTypeContext::R_BRACKET() {
  return getToken(GoParser::R_BRACKET, 0);
}

GoParser::ElementTypeContext* GoParser::SliceTypeContext::elementType() {
  return getRuleContext<GoParser::ElementTypeContext>(0);
}


size_t GoParser::SliceTypeContext::getRuleIndex() const {
  return GoParser::RuleSliceType;
}


std::any GoParser::SliceTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitSliceType(this);
  else
    return visitor->visitChildren(this);
}

GoParser::SliceTypeContext* GoParser::sliceType() {
  SliceTypeContext *_localctx = _tracker.createInstance<SliceTypeContext>(_ctx, getState());
  enterRule(_localctx, 134, GoParser::RuleSliceType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(725);
    match(GoParser::L_BRACKET);
    setState(726);
    match(GoParser::R_BRACKET);
    setState(727);
    elementType();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MapTypeContext ------------------------------------------------------------------

GoParser::MapTypeContext::MapTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GoParser::MapTypeContext::MAP() {
  return getToken(GoParser::MAP, 0);
}

tree::TerminalNode* GoParser::MapTypeContext::L_BRACKET() {
  return getToken(GoParser::L_BRACKET, 0);
}

GoParser::Type_Context* GoParser::MapTypeContext::type_() {
  return getRuleContext<GoParser::Type_Context>(0);
}

tree::TerminalNode* GoParser::MapTypeContext::R_BRACKET() {
  return getToken(GoParser::R_BRACKET, 0);
}

GoParser::ElementTypeContext* GoParser::MapTypeContext::elementType() {
  return getRuleContext<GoParser::ElementTypeContext>(0);
}


size_t GoParser::MapTypeContext::getRuleIndex() const {
  return GoParser::RuleMapType;
}


std::any GoParser::MapTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitMapType(this);
  else
    return visitor->visitChildren(this);
}

GoParser::MapTypeContext* GoParser::mapType() {
  MapTypeContext *_localctx = _tracker.createInstance<MapTypeContext>(_ctx, getState());
  enterRule(_localctx, 136, GoParser::RuleMapType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(729);
    match(GoParser::MAP);
    setState(730);
    match(GoParser::L_BRACKET);
    setState(731);
    type_();
    setState(732);
    match(GoParser::R_BRACKET);
    setState(733);
    elementType();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ChannelTypeContext ------------------------------------------------------------------

GoParser::ChannelTypeContext::ChannelTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GoParser::ElementTypeContext* GoParser::ChannelTypeContext::elementType() {
  return getRuleContext<GoParser::ElementTypeContext>(0);
}

tree::TerminalNode* GoParser::ChannelTypeContext::CHAN() {
  return getToken(GoParser::CHAN, 0);
}

tree::TerminalNode* GoParser::ChannelTypeContext::RECEIVE() {
  return getToken(GoParser::RECEIVE, 0);
}


size_t GoParser::ChannelTypeContext::getRuleIndex() const {
  return GoParser::RuleChannelType;
}


std::any GoParser::ChannelTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitChannelType(this);
  else
    return visitor->visitChildren(this);
}

GoParser::ChannelTypeContext* GoParser::channelType() {
  ChannelTypeContext *_localctx = _tracker.createInstance<ChannelTypeContext>(_ctx, getState());
  enterRule(_localctx, 138, GoParser::RuleChannelType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(740);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 77, _ctx)) {
    case 1: {
      setState(735);
      match(GoParser::CHAN);
      break;
    }

    case 2: {
      setState(736);
      match(GoParser::CHAN);
      setState(737);
      match(GoParser::RECEIVE);
      break;
    }

    case 3: {
      setState(738);
      match(GoParser::RECEIVE);
      setState(739);
      match(GoParser::CHAN);
      break;
    }

    default:
      break;
    }
    setState(742);
    elementType();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MethodSpecContext ------------------------------------------------------------------

GoParser::MethodSpecContext::MethodSpecContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GoParser::MethodSpecContext::IDENTIFIER() {
  return getToken(GoParser::IDENTIFIER, 0);
}

GoParser::ParametersContext* GoParser::MethodSpecContext::parameters() {
  return getRuleContext<GoParser::ParametersContext>(0);
}

GoParser::ResultContext* GoParser::MethodSpecContext::result() {
  return getRuleContext<GoParser::ResultContext>(0);
}


size_t GoParser::MethodSpecContext::getRuleIndex() const {
  return GoParser::RuleMethodSpec;
}


std::any GoParser::MethodSpecContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitMethodSpec(this);
  else
    return visitor->visitChildren(this);
}

GoParser::MethodSpecContext* GoParser::methodSpec() {
  MethodSpecContext *_localctx = _tracker.createInstance<MethodSpecContext>(_ctx, getState());
  enterRule(_localctx, 140, GoParser::RuleMethodSpec);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(750);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 78, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(744);
      match(GoParser::IDENTIFIER);
      setState(745);
      parameters();
      setState(746);
      result();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(748);
      match(GoParser::IDENTIFIER);
      setState(749);
      parameters();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionTypeContext ------------------------------------------------------------------

GoParser::FunctionTypeContext::FunctionTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GoParser::FunctionTypeContext::FUNC() {
  return getToken(GoParser::FUNC, 0);
}

GoParser::SignatureContext* GoParser::FunctionTypeContext::signature() {
  return getRuleContext<GoParser::SignatureContext>(0);
}


size_t GoParser::FunctionTypeContext::getRuleIndex() const {
  return GoParser::RuleFunctionType;
}


std::any GoParser::FunctionTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitFunctionType(this);
  else
    return visitor->visitChildren(this);
}

GoParser::FunctionTypeContext* GoParser::functionType() {
  FunctionTypeContext *_localctx = _tracker.createInstance<FunctionTypeContext>(_ctx, getState());
  enterRule(_localctx, 142, GoParser::RuleFunctionType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(752);
    match(GoParser::FUNC);
    setState(753);
    signature();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SignatureContext ------------------------------------------------------------------

GoParser::SignatureContext::SignatureContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GoParser::ParametersContext* GoParser::SignatureContext::parameters() {
  return getRuleContext<GoParser::ParametersContext>(0);
}

GoParser::ResultContext* GoParser::SignatureContext::result() {
  return getRuleContext<GoParser::ResultContext>(0);
}


size_t GoParser::SignatureContext::getRuleIndex() const {
  return GoParser::RuleSignature;
}


std::any GoParser::SignatureContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitSignature(this);
  else
    return visitor->visitChildren(this);
}

GoParser::SignatureContext* GoParser::signature() {
  SignatureContext *_localctx = _tracker.createInstance<SignatureContext>(_ctx, getState());
  enterRule(_localctx, 144, GoParser::RuleSignature);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(755);
    parameters();
    setState(757);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 79, _ctx)) {
    case 1: {
      setState(756);
      result();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ResultContext ------------------------------------------------------------------

GoParser::ResultContext::ResultContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GoParser::ParametersContext* GoParser::ResultContext::parameters() {
  return getRuleContext<GoParser::ParametersContext>(0);
}

GoParser::Type_Context* GoParser::ResultContext::type_() {
  return getRuleContext<GoParser::Type_Context>(0);
}


size_t GoParser::ResultContext::getRuleIndex() const {
  return GoParser::RuleResult;
}


std::any GoParser::ResultContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitResult(this);
  else
    return visitor->visitChildren(this);
}

GoParser::ResultContext* GoParser::result() {
  ResultContext *_localctx = _tracker.createInstance<ResultContext>(_ctx, getState());
  enterRule(_localctx, 146, GoParser::RuleResult);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(761);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 80, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(759);
      parameters();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(760);
      type_();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ParametersContext ------------------------------------------------------------------

GoParser::ParametersContext::ParametersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GoParser::ParametersContext::L_PAREN() {
  return getToken(GoParser::L_PAREN, 0);
}

tree::TerminalNode* GoParser::ParametersContext::R_PAREN() {
  return getToken(GoParser::R_PAREN, 0);
}

std::vector<GoParser::ParameterDeclContext *> GoParser::ParametersContext::parameterDecl() {
  return getRuleContexts<GoParser::ParameterDeclContext>();
}

GoParser::ParameterDeclContext* GoParser::ParametersContext::parameterDecl(size_t i) {
  return getRuleContext<GoParser::ParameterDeclContext>(i);
}

std::vector<tree::TerminalNode *> GoParser::ParametersContext::COMMA() {
  return getTokens(GoParser::COMMA);
}

tree::TerminalNode* GoParser::ParametersContext::COMMA(size_t i) {
  return getToken(GoParser::COMMA, i);
}


size_t GoParser::ParametersContext::getRuleIndex() const {
  return GoParser::RuleParameters;
}


std::any GoParser::ParametersContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitParameters(this);
  else
    return visitor->visitChildren(this);
}

GoParser::ParametersContext* GoParser::parameters() {
  ParametersContext *_localctx = _tracker.createInstance<ParametersContext>(_ctx, getState());
  enterRule(_localctx, 148, GoParser::RuleParameters);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(763);
    match(GoParser::L_PAREN);
    setState(775);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 3) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 3)) & 2882304311860134339) != 0)) {
      setState(764);
      parameterDecl();
      setState(769);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 81, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(765);
          match(GoParser::COMMA);
          setState(766);
          parameterDecl(); 
        }
        setState(771);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 81, _ctx);
      }
      setState(773);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GoParser::COMMA) {
        setState(772);
        match(GoParser::COMMA);
      }
    }
    setState(777);
    match(GoParser::R_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ParameterDeclContext ------------------------------------------------------------------

GoParser::ParameterDeclContext::ParameterDeclContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GoParser::Type_Context* GoParser::ParameterDeclContext::type_() {
  return getRuleContext<GoParser::Type_Context>(0);
}

GoParser::IdentifierListContext* GoParser::ParameterDeclContext::identifierList() {
  return getRuleContext<GoParser::IdentifierListContext>(0);
}

tree::TerminalNode* GoParser::ParameterDeclContext::ELLIPSIS() {
  return getToken(GoParser::ELLIPSIS, 0);
}


size_t GoParser::ParameterDeclContext::getRuleIndex() const {
  return GoParser::RuleParameterDecl;
}


std::any GoParser::ParameterDeclContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitParameterDecl(this);
  else
    return visitor->visitChildren(this);
}

GoParser::ParameterDeclContext* GoParser::parameterDecl() {
  ParameterDeclContext *_localctx = _tracker.createInstance<ParameterDeclContext>(_ctx, getState());
  enterRule(_localctx, 150, GoParser::RuleParameterDecl);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(780);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 84, _ctx)) {
    case 1: {
      setState(779);
      identifierList();
      break;
    }

    default:
      break;
    }
    setState(783);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GoParser::ELLIPSIS) {
      setState(782);
      match(GoParser::ELLIPSIS);
    }
    setState(785);
    type_();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExpressionContext ------------------------------------------------------------------

GoParser::ExpressionContext::ExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GoParser::PrimaryExprContext* GoParser::ExpressionContext::primaryExpr() {
  return getRuleContext<GoParser::PrimaryExprContext>(0);
}

std::vector<GoParser::ExpressionContext *> GoParser::ExpressionContext::expression() {
  return getRuleContexts<GoParser::ExpressionContext>();
}

GoParser::ExpressionContext* GoParser::ExpressionContext::expression(size_t i) {
  return getRuleContext<GoParser::ExpressionContext>(i);
}

tree::TerminalNode* GoParser::ExpressionContext::PLUS() {
  return getToken(GoParser::PLUS, 0);
}

tree::TerminalNode* GoParser::ExpressionContext::MINUS() {
  return getToken(GoParser::MINUS, 0);
}

tree::TerminalNode* GoParser::ExpressionContext::EXCLAMATION() {
  return getToken(GoParser::EXCLAMATION, 0);
}

tree::TerminalNode* GoParser::ExpressionContext::CARET() {
  return getToken(GoParser::CARET, 0);
}

tree::TerminalNode* GoParser::ExpressionContext::STAR() {
  return getToken(GoParser::STAR, 0);
}

tree::TerminalNode* GoParser::ExpressionContext::AMPERSAND() {
  return getToken(GoParser::AMPERSAND, 0);
}

tree::TerminalNode* GoParser::ExpressionContext::RECEIVE() {
  return getToken(GoParser::RECEIVE, 0);
}

tree::TerminalNode* GoParser::ExpressionContext::DIV() {
  return getToken(GoParser::DIV, 0);
}

tree::TerminalNode* GoParser::ExpressionContext::MOD() {
  return getToken(GoParser::MOD, 0);
}

tree::TerminalNode* GoParser::ExpressionContext::LSHIFT() {
  return getToken(GoParser::LSHIFT, 0);
}

tree::TerminalNode* GoParser::ExpressionContext::RSHIFT() {
  return getToken(GoParser::RSHIFT, 0);
}

tree::TerminalNode* GoParser::ExpressionContext::BIT_CLEAR() {
  return getToken(GoParser::BIT_CLEAR, 0);
}

tree::TerminalNode* GoParser::ExpressionContext::OR() {
  return getToken(GoParser::OR, 0);
}

tree::TerminalNode* GoParser::ExpressionContext::EQUALS() {
  return getToken(GoParser::EQUALS, 0);
}

tree::TerminalNode* GoParser::ExpressionContext::NOT_EQUALS() {
  return getToken(GoParser::NOT_EQUALS, 0);
}

tree::TerminalNode* GoParser::ExpressionContext::LESS() {
  return getToken(GoParser::LESS, 0);
}

tree::TerminalNode* GoParser::ExpressionContext::LESS_OR_EQUALS() {
  return getToken(GoParser::LESS_OR_EQUALS, 0);
}

tree::TerminalNode* GoParser::ExpressionContext::GREATER() {
  return getToken(GoParser::GREATER, 0);
}

tree::TerminalNode* GoParser::ExpressionContext::GREATER_OR_EQUALS() {
  return getToken(GoParser::GREATER_OR_EQUALS, 0);
}

tree::TerminalNode* GoParser::ExpressionContext::LOGICAL_AND() {
  return getToken(GoParser::LOGICAL_AND, 0);
}

tree::TerminalNode* GoParser::ExpressionContext::LOGICAL_OR() {
  return getToken(GoParser::LOGICAL_OR, 0);
}


size_t GoParser::ExpressionContext::getRuleIndex() const {
  return GoParser::RuleExpression;
}


std::any GoParser::ExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitExpression(this);
  else
    return visitor->visitChildren(this);
}


GoParser::ExpressionContext* GoParser::expression() {
   return expression(0);
}

GoParser::ExpressionContext* GoParser::expression(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  GoParser::ExpressionContext *_localctx = _tracker.createInstance<ExpressionContext>(_ctx, parentState);
  GoParser::ExpressionContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 152;
  enterRecursionRule(_localctx, 152, GoParser::RuleExpression, precedence);

    size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(791);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 86, _ctx)) {
    case 1: {
      setState(788);
      primaryExpr(0);
      break;
    }

    case 2: {
      setState(789);
      antlrcpp::downCast<ExpressionContext *>(_localctx)->unary_op = _input->LT(1);
      _la = _input->LA(1);
      if (!(((((_la - 58) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 58)) & 127) != 0))) {
        antlrcpp::downCast<ExpressionContext *>(_localctx)->unary_op = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(790);
      expression(6);
      break;
    }

    default:
      break;
    }
    _ctx->stop = _input->LT(-1);
    setState(810);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 88, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(808);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 87, _ctx)) {
        case 1: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(793);

          if (!(precpred(_ctx, 5))) throw FailedPredicateException(this, "precpred(_ctx, 5)");
          setState(794);
          antlrcpp::downCast<ExpressionContext *>(_localctx)->mul_op = _input->LT(1);
          _la = _input->LA(1);
          if (!((((_la & ~ 0x3fULL) == 0) &&
            ((1ULL << _la) & -4472074429978902528) != 0))) {
            antlrcpp::downCast<ExpressionContext *>(_localctx)->mul_op = _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(795);
          expression(6);
          break;
        }

        case 2: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(796);

          if (!(precpred(_ctx, 4))) throw FailedPredicateException(this, "precpred(_ctx, 4)");
          setState(797);
          antlrcpp::downCast<ExpressionContext *>(_localctx)->add_op = _input->LT(1);
          _la = _input->LA(1);
          if (!((((_la & ~ 0x3fULL) == 0) &&
            ((1ULL << _la) & 4037477065937649664) != 0))) {
            antlrcpp::downCast<ExpressionContext *>(_localctx)->add_op = _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(798);
          expression(5);
          break;
        }

        case 3: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(799);

          if (!(precpred(_ctx, 3))) throw FailedPredicateException(this, "precpred(_ctx, 3)");
          setState(800);
          antlrcpp::downCast<ExpressionContext *>(_localctx)->rel_op = _input->LT(1);
          _la = _input->LA(1);
          if (!((((_la & ~ 0x3fULL) == 0) &&
            ((1ULL << _la) & 2216615441596416) != 0))) {
            antlrcpp::downCast<ExpressionContext *>(_localctx)->rel_op = _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(801);
          expression(4);
          break;
        }

        case 4: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(802);

          if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
          setState(803);
          match(GoParser::LOGICAL_AND);
          setState(804);
          expression(3);
          break;
        }

        case 5: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(805);

          if (!(precpred(_ctx, 1))) throw FailedPredicateException(this, "precpred(_ctx, 1)");
          setState(806);
          match(GoParser::LOGICAL_OR);
          setState(807);
          expression(2);
          break;
        }

        default:
          break;
        } 
      }
      setState(812);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 88, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- PrimaryExprContext ------------------------------------------------------------------

GoParser::PrimaryExprContext::PrimaryExprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GoParser::OperandContext* GoParser::PrimaryExprContext::operand() {
  return getRuleContext<GoParser::OperandContext>(0);
}

GoParser::ConversionContext* GoParser::PrimaryExprContext::conversion() {
  return getRuleContext<GoParser::ConversionContext>(0);
}

GoParser::MethodExprContext* GoParser::PrimaryExprContext::methodExpr() {
  return getRuleContext<GoParser::MethodExprContext>(0);
}

GoParser::PrimaryExprContext* GoParser::PrimaryExprContext::primaryExpr() {
  return getRuleContext<GoParser::PrimaryExprContext>(0);
}

tree::TerminalNode* GoParser::PrimaryExprContext::DOT() {
  return getToken(GoParser::DOT, 0);
}

tree::TerminalNode* GoParser::PrimaryExprContext::IDENTIFIER() {
  return getToken(GoParser::IDENTIFIER, 0);
}

GoParser::IndexContext* GoParser::PrimaryExprContext::index() {
  return getRuleContext<GoParser::IndexContext>(0);
}

GoParser::Slice_Context* GoParser::PrimaryExprContext::slice_() {
  return getRuleContext<GoParser::Slice_Context>(0);
}

GoParser::TypeAssertionContext* GoParser::PrimaryExprContext::typeAssertion() {
  return getRuleContext<GoParser::TypeAssertionContext>(0);
}

GoParser::ArgumentsContext* GoParser::PrimaryExprContext::arguments() {
  return getRuleContext<GoParser::ArgumentsContext>(0);
}


size_t GoParser::PrimaryExprContext::getRuleIndex() const {
  return GoParser::RulePrimaryExpr;
}


std::any GoParser::PrimaryExprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitPrimaryExpr(this);
  else
    return visitor->visitChildren(this);
}


GoParser::PrimaryExprContext* GoParser::primaryExpr() {
   return primaryExpr(0);
}

GoParser::PrimaryExprContext* GoParser::primaryExpr(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  GoParser::PrimaryExprContext *_localctx = _tracker.createInstance<PrimaryExprContext>(_ctx, parentState);
  GoParser::PrimaryExprContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 154;
  enterRecursionRule(_localctx, 154, GoParser::RulePrimaryExpr, precedence);

    

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(817);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 89, _ctx)) {
    case 1: {
      setState(814);
      operand();
      break;
    }

    case 2: {
      setState(815);
      conversion();
      break;
    }

    case 3: {
      setState(816);
      methodExpr();
      break;
    }

    default:
      break;
    }
    _ctx->stop = _input->LT(-1);
    setState(830);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 91, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        _localctx = _tracker.createInstance<PrimaryExprContext>(parentContext, parentState);
        pushNewRecursionContext(_localctx, startState, RulePrimaryExpr);
        setState(819);

        if (!(precpred(_ctx, 1))) throw FailedPredicateException(this, "precpred(_ctx, 1)");
        setState(826);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 90, _ctx)) {
        case 1: {
          setState(820);
          match(GoParser::DOT);
          setState(821);
          match(GoParser::IDENTIFIER);
          break;
        }

        case 2: {
          setState(822);
          index();
          break;
        }

        case 3: {
          setState(823);
          slice_();
          break;
        }

        case 4: {
          setState(824);
          typeAssertion();
          break;
        }

        case 5: {
          setState(825);
          arguments();
          break;
        }

        default:
          break;
        } 
      }
      setState(832);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 91, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- ConversionContext ------------------------------------------------------------------

GoParser::ConversionContext::ConversionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GoParser::Type_Context* GoParser::ConversionContext::type_() {
  return getRuleContext<GoParser::Type_Context>(0);
}

tree::TerminalNode* GoParser::ConversionContext::L_PAREN() {
  return getToken(GoParser::L_PAREN, 0);
}

GoParser::ExpressionContext* GoParser::ConversionContext::expression() {
  return getRuleContext<GoParser::ExpressionContext>(0);
}

tree::TerminalNode* GoParser::ConversionContext::R_PAREN() {
  return getToken(GoParser::R_PAREN, 0);
}

tree::TerminalNode* GoParser::ConversionContext::COMMA() {
  return getToken(GoParser::COMMA, 0);
}


size_t GoParser::ConversionContext::getRuleIndex() const {
  return GoParser::RuleConversion;
}


std::any GoParser::ConversionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitConversion(this);
  else
    return visitor->visitChildren(this);
}

GoParser::ConversionContext* GoParser::conversion() {
  ConversionContext *_localctx = _tracker.createInstance<ConversionContext>(_ctx, getState());
  enterRule(_localctx, 156, GoParser::RuleConversion);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(833);
    type_();
    setState(834);
    match(GoParser::L_PAREN);
    setState(835);
    expression(0);
    setState(837);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GoParser::COMMA) {
      setState(836);
      match(GoParser::COMMA);
    }
    setState(839);
    match(GoParser::R_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OperandContext ------------------------------------------------------------------

GoParser::OperandContext::OperandContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GoParser::LiteralContext* GoParser::OperandContext::literal() {
  return getRuleContext<GoParser::LiteralContext>(0);
}

GoParser::OperandNameContext* GoParser::OperandContext::operandName() {
  return getRuleContext<GoParser::OperandNameContext>(0);
}

GoParser::TypeArgsContext* GoParser::OperandContext::typeArgs() {
  return getRuleContext<GoParser::TypeArgsContext>(0);
}

tree::TerminalNode* GoParser::OperandContext::L_PAREN() {
  return getToken(GoParser::L_PAREN, 0);
}

GoParser::ExpressionContext* GoParser::OperandContext::expression() {
  return getRuleContext<GoParser::ExpressionContext>(0);
}

tree::TerminalNode* GoParser::OperandContext::R_PAREN() {
  return getToken(GoParser::R_PAREN, 0);
}


size_t GoParser::OperandContext::getRuleIndex() const {
  return GoParser::RuleOperand;
}


std::any GoParser::OperandContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitOperand(this);
  else
    return visitor->visitChildren(this);
}

GoParser::OperandContext* GoParser::operand() {
  OperandContext *_localctx = _tracker.createInstance<OperandContext>(_ctx, getState());
  enterRule(_localctx, 158, GoParser::RuleOperand);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(850);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 94, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(841);
      literal();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(842);
      operandName();
      setState(844);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 93, _ctx)) {
      case 1: {
        setState(843);
        typeArgs();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(846);
      match(GoParser::L_PAREN);
      setState(847);
      expression(0);
      setState(848);
      match(GoParser::R_PAREN);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LiteralContext ------------------------------------------------------------------

GoParser::LiteralContext::LiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GoParser::BasicLitContext* GoParser::LiteralContext::basicLit() {
  return getRuleContext<GoParser::BasicLitContext>(0);
}

GoParser::CompositeLitContext* GoParser::LiteralContext::compositeLit() {
  return getRuleContext<GoParser::CompositeLitContext>(0);
}

GoParser::FunctionLitContext* GoParser::LiteralContext::functionLit() {
  return getRuleContext<GoParser::FunctionLitContext>(0);
}


size_t GoParser::LiteralContext::getRuleIndex() const {
  return GoParser::RuleLiteral;
}


std::any GoParser::LiteralContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitLiteral(this);
  else
    return visitor->visitChildren(this);
}

GoParser::LiteralContext* GoParser::literal() {
  LiteralContext *_localctx = _tracker.createInstance<LiteralContext>(_ctx, getState());
  enterRule(_localctx, 160, GoParser::RuleLiteral);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(855);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GoParser::NIL_LIT:
      case GoParser::DECIMAL_LIT:
      case GoParser::BINARY_LIT:
      case GoParser::OCTAL_LIT:
      case GoParser::HEX_LIT:
      case GoParser::FLOAT_LIT:
      case GoParser::IMAGINARY_LIT:
      case GoParser::RUNE_LIT:
      case GoParser::RAW_STRING_LIT:
      case GoParser::INTERPRETED_STRING_LIT: {
        enterOuterAlt(_localctx, 1);
        setState(852);
        basicLit();
        break;
      }

      case GoParser::MAP:
      case GoParser::STRUCT:
      case GoParser::IDENTIFIER:
      case GoParser::L_BRACKET: {
        enterOuterAlt(_localctx, 2);
        setState(853);
        compositeLit();
        break;
      }

      case GoParser::FUNC: {
        enterOuterAlt(_localctx, 3);
        setState(854);
        functionLit();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BasicLitContext ------------------------------------------------------------------

GoParser::BasicLitContext::BasicLitContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GoParser::BasicLitContext::NIL_LIT() {
  return getToken(GoParser::NIL_LIT, 0);
}

GoParser::IntegerContext* GoParser::BasicLitContext::integer() {
  return getRuleContext<GoParser::IntegerContext>(0);
}

GoParser::String_Context* GoParser::BasicLitContext::string_() {
  return getRuleContext<GoParser::String_Context>(0);
}

tree::TerminalNode* GoParser::BasicLitContext::FLOAT_LIT() {
  return getToken(GoParser::FLOAT_LIT, 0);
}


size_t GoParser::BasicLitContext::getRuleIndex() const {
  return GoParser::RuleBasicLit;
}


std::any GoParser::BasicLitContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitBasicLit(this);
  else
    return visitor->visitChildren(this);
}

GoParser::BasicLitContext* GoParser::basicLit() {
  BasicLitContext *_localctx = _tracker.createInstance<BasicLitContext>(_ctx, getState());
  enterRule(_localctx, 162, GoParser::RuleBasicLit);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(861);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GoParser::NIL_LIT: {
        enterOuterAlt(_localctx, 1);
        setState(857);
        match(GoParser::NIL_LIT);
        break;
      }

      case GoParser::DECIMAL_LIT:
      case GoParser::BINARY_LIT:
      case GoParser::OCTAL_LIT:
      case GoParser::HEX_LIT:
      case GoParser::IMAGINARY_LIT:
      case GoParser::RUNE_LIT: {
        enterOuterAlt(_localctx, 2);
        setState(858);
        integer();
        break;
      }

      case GoParser::RAW_STRING_LIT:
      case GoParser::INTERPRETED_STRING_LIT: {
        enterOuterAlt(_localctx, 3);
        setState(859);
        string_();
        break;
      }

      case GoParser::FLOAT_LIT: {
        enterOuterAlt(_localctx, 4);
        setState(860);
        match(GoParser::FLOAT_LIT);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IntegerContext ------------------------------------------------------------------

GoParser::IntegerContext::IntegerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GoParser::IntegerContext::DECIMAL_LIT() {
  return getToken(GoParser::DECIMAL_LIT, 0);
}

tree::TerminalNode* GoParser::IntegerContext::BINARY_LIT() {
  return getToken(GoParser::BINARY_LIT, 0);
}

tree::TerminalNode* GoParser::IntegerContext::OCTAL_LIT() {
  return getToken(GoParser::OCTAL_LIT, 0);
}

tree::TerminalNode* GoParser::IntegerContext::HEX_LIT() {
  return getToken(GoParser::HEX_LIT, 0);
}

tree::TerminalNode* GoParser::IntegerContext::IMAGINARY_LIT() {
  return getToken(GoParser::IMAGINARY_LIT, 0);
}

tree::TerminalNode* GoParser::IntegerContext::RUNE_LIT() {
  return getToken(GoParser::RUNE_LIT, 0);
}


size_t GoParser::IntegerContext::getRuleIndex() const {
  return GoParser::RuleInteger;
}


std::any GoParser::IntegerContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitInteger(this);
  else
    return visitor->visitChildren(this);
}

GoParser::IntegerContext* GoParser::integer() {
  IntegerContext *_localctx = _tracker.createInstance<IntegerContext>(_ctx, getState());
  enterRule(_localctx, 164, GoParser::RuleInteger);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(863);
    _la = _input->LA(1);
    if (!(((((_la - 65) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 65)) & 399) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OperandNameContext ------------------------------------------------------------------

GoParser::OperandNameContext::OperandNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GoParser::OperandNameContext::IDENTIFIER() {
  return getToken(GoParser::IDENTIFIER, 0);
}


size_t GoParser::OperandNameContext::getRuleIndex() const {
  return GoParser::RuleOperandName;
}


std::any GoParser::OperandNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitOperandName(this);
  else
    return visitor->visitChildren(this);
}

GoParser::OperandNameContext* GoParser::operandName() {
  OperandNameContext *_localctx = _tracker.createInstance<OperandNameContext>(_ctx, getState());
  enterRule(_localctx, 166, GoParser::RuleOperandName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(865);
    match(GoParser::IDENTIFIER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QualifiedIdentContext ------------------------------------------------------------------

GoParser::QualifiedIdentContext::QualifiedIdentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> GoParser::QualifiedIdentContext::IDENTIFIER() {
  return getTokens(GoParser::IDENTIFIER);
}

tree::TerminalNode* GoParser::QualifiedIdentContext::IDENTIFIER(size_t i) {
  return getToken(GoParser::IDENTIFIER, i);
}

tree::TerminalNode* GoParser::QualifiedIdentContext::DOT() {
  return getToken(GoParser::DOT, 0);
}


size_t GoParser::QualifiedIdentContext::getRuleIndex() const {
  return GoParser::RuleQualifiedIdent;
}


std::any GoParser::QualifiedIdentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitQualifiedIdent(this);
  else
    return visitor->visitChildren(this);
}

GoParser::QualifiedIdentContext* GoParser::qualifiedIdent() {
  QualifiedIdentContext *_localctx = _tracker.createInstance<QualifiedIdentContext>(_ctx, getState());
  enterRule(_localctx, 168, GoParser::RuleQualifiedIdent);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(867);
    match(GoParser::IDENTIFIER);
    setState(868);
    match(GoParser::DOT);
    setState(869);
    match(GoParser::IDENTIFIER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CompositeLitContext ------------------------------------------------------------------

GoParser::CompositeLitContext::CompositeLitContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GoParser::LiteralTypeContext* GoParser::CompositeLitContext::literalType() {
  return getRuleContext<GoParser::LiteralTypeContext>(0);
}

GoParser::LiteralValueContext* GoParser::CompositeLitContext::literalValue() {
  return getRuleContext<GoParser::LiteralValueContext>(0);
}


size_t GoParser::CompositeLitContext::getRuleIndex() const {
  return GoParser::RuleCompositeLit;
}


std::any GoParser::CompositeLitContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitCompositeLit(this);
  else
    return visitor->visitChildren(this);
}

GoParser::CompositeLitContext* GoParser::compositeLit() {
  CompositeLitContext *_localctx = _tracker.createInstance<CompositeLitContext>(_ctx, getState());
  enterRule(_localctx, 170, GoParser::RuleCompositeLit);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(871);
    literalType();
    setState(872);
    literalValue();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LiteralTypeContext ------------------------------------------------------------------

GoParser::LiteralTypeContext::LiteralTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GoParser::StructTypeContext* GoParser::LiteralTypeContext::structType() {
  return getRuleContext<GoParser::StructTypeContext>(0);
}

GoParser::ArrayTypeContext* GoParser::LiteralTypeContext::arrayType() {
  return getRuleContext<GoParser::ArrayTypeContext>(0);
}

tree::TerminalNode* GoParser::LiteralTypeContext::L_BRACKET() {
  return getToken(GoParser::L_BRACKET, 0);
}

tree::TerminalNode* GoParser::LiteralTypeContext::ELLIPSIS() {
  return getToken(GoParser::ELLIPSIS, 0);
}

tree::TerminalNode* GoParser::LiteralTypeContext::R_BRACKET() {
  return getToken(GoParser::R_BRACKET, 0);
}

GoParser::ElementTypeContext* GoParser::LiteralTypeContext::elementType() {
  return getRuleContext<GoParser::ElementTypeContext>(0);
}

GoParser::SliceTypeContext* GoParser::LiteralTypeContext::sliceType() {
  return getRuleContext<GoParser::SliceTypeContext>(0);
}

GoParser::MapTypeContext* GoParser::LiteralTypeContext::mapType() {
  return getRuleContext<GoParser::MapTypeContext>(0);
}

GoParser::TypeNameContext* GoParser::LiteralTypeContext::typeName() {
  return getRuleContext<GoParser::TypeNameContext>(0);
}

GoParser::TypeArgsContext* GoParser::LiteralTypeContext::typeArgs() {
  return getRuleContext<GoParser::TypeArgsContext>(0);
}


size_t GoParser::LiteralTypeContext::getRuleIndex() const {
  return GoParser::RuleLiteralType;
}


std::any GoParser::LiteralTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitLiteralType(this);
  else
    return visitor->visitChildren(this);
}

GoParser::LiteralTypeContext* GoParser::literalType() {
  LiteralTypeContext *_localctx = _tracker.createInstance<LiteralTypeContext>(_ctx, getState());
  enterRule(_localctx, 172, GoParser::RuleLiteralType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(886);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 98, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(874);
      structType();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(875);
      arrayType();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(876);
      match(GoParser::L_BRACKET);
      setState(877);
      match(GoParser::ELLIPSIS);
      setState(878);
      match(GoParser::R_BRACKET);
      setState(879);
      elementType();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(880);
      sliceType();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(881);
      mapType();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(882);
      typeName();
      setState(884);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GoParser::L_BRACKET) {
        setState(883);
        typeArgs();
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LiteralValueContext ------------------------------------------------------------------

GoParser::LiteralValueContext::LiteralValueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GoParser::LiteralValueContext::L_CURLY() {
  return getToken(GoParser::L_CURLY, 0);
}

tree::TerminalNode* GoParser::LiteralValueContext::R_CURLY() {
  return getToken(GoParser::R_CURLY, 0);
}

GoParser::ElementListContext* GoParser::LiteralValueContext::elementList() {
  return getRuleContext<GoParser::ElementListContext>(0);
}

tree::TerminalNode* GoParser::LiteralValueContext::COMMA() {
  return getToken(GoParser::COMMA, 0);
}


size_t GoParser::LiteralValueContext::getRuleIndex() const {
  return GoParser::RuleLiteralValue;
}


std::any GoParser::LiteralValueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitLiteralValue(this);
  else
    return visitor->visitChildren(this);
}

GoParser::LiteralValueContext* GoParser::literalValue() {
  LiteralValueContext *_localctx = _tracker.createInstance<LiteralValueContext>(_ctx, getState());
  enterRule(_localctx, 174, GoParser::RuleLiteralValue);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(888);
    match(GoParser::L_CURLY);
    setState(893);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -288230370313236968) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 99135) != 0)) {
      setState(889);
      elementList();
      setState(891);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GoParser::COMMA) {
        setState(890);
        match(GoParser::COMMA);
      }
    }
    setState(895);
    match(GoParser::R_CURLY);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ElementListContext ------------------------------------------------------------------

GoParser::ElementListContext::ElementListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GoParser::KeyedElementContext *> GoParser::ElementListContext::keyedElement() {
  return getRuleContexts<GoParser::KeyedElementContext>();
}

GoParser::KeyedElementContext* GoParser::ElementListContext::keyedElement(size_t i) {
  return getRuleContext<GoParser::KeyedElementContext>(i);
}

std::vector<tree::TerminalNode *> GoParser::ElementListContext::COMMA() {
  return getTokens(GoParser::COMMA);
}

tree::TerminalNode* GoParser::ElementListContext::COMMA(size_t i) {
  return getToken(GoParser::COMMA, i);
}


size_t GoParser::ElementListContext::getRuleIndex() const {
  return GoParser::RuleElementList;
}


std::any GoParser::ElementListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitElementList(this);
  else
    return visitor->visitChildren(this);
}

GoParser::ElementListContext* GoParser::elementList() {
  ElementListContext *_localctx = _tracker.createInstance<ElementListContext>(_ctx, getState());
  enterRule(_localctx, 176, GoParser::RuleElementList);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(897);
    keyedElement();
    setState(902);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 101, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(898);
        match(GoParser::COMMA);
        setState(899);
        keyedElement(); 
      }
      setState(904);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 101, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KeyedElementContext ------------------------------------------------------------------

GoParser::KeyedElementContext::KeyedElementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GoParser::ElementContext* GoParser::KeyedElementContext::element() {
  return getRuleContext<GoParser::ElementContext>(0);
}

GoParser::KeyContext* GoParser::KeyedElementContext::key() {
  return getRuleContext<GoParser::KeyContext>(0);
}

tree::TerminalNode* GoParser::KeyedElementContext::COLON() {
  return getToken(GoParser::COLON, 0);
}


size_t GoParser::KeyedElementContext::getRuleIndex() const {
  return GoParser::RuleKeyedElement;
}


std::any GoParser::KeyedElementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitKeyedElement(this);
  else
    return visitor->visitChildren(this);
}

GoParser::KeyedElementContext* GoParser::keyedElement() {
  KeyedElementContext *_localctx = _tracker.createInstance<KeyedElementContext>(_ctx, getState());
  enterRule(_localctx, 178, GoParser::RuleKeyedElement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(908);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 102, _ctx)) {
    case 1: {
      setState(905);
      key();
      setState(906);
      match(GoParser::COLON);
      break;
    }

    default:
      break;
    }
    setState(910);
    element();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KeyContext ------------------------------------------------------------------

GoParser::KeyContext::KeyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GoParser::ExpressionContext* GoParser::KeyContext::expression() {
  return getRuleContext<GoParser::ExpressionContext>(0);
}

GoParser::LiteralValueContext* GoParser::KeyContext::literalValue() {
  return getRuleContext<GoParser::LiteralValueContext>(0);
}


size_t GoParser::KeyContext::getRuleIndex() const {
  return GoParser::RuleKey;
}


std::any GoParser::KeyContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitKey(this);
  else
    return visitor->visitChildren(this);
}

GoParser::KeyContext* GoParser::key() {
  KeyContext *_localctx = _tracker.createInstance<KeyContext>(_ctx, getState());
  enterRule(_localctx, 180, GoParser::RuleKey);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(914);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GoParser::FUNC:
      case GoParser::INTERFACE:
      case GoParser::MAP:
      case GoParser::STRUCT:
      case GoParser::CHAN:
      case GoParser::NIL_LIT:
      case GoParser::IDENTIFIER:
      case GoParser::L_PAREN:
      case GoParser::L_BRACKET:
      case GoParser::EXCLAMATION:
      case GoParser::PLUS:
      case GoParser::MINUS:
      case GoParser::CARET:
      case GoParser::STAR:
      case GoParser::AMPERSAND:
      case GoParser::RECEIVE:
      case GoParser::DECIMAL_LIT:
      case GoParser::BINARY_LIT:
      case GoParser::OCTAL_LIT:
      case GoParser::HEX_LIT:
      case GoParser::FLOAT_LIT:
      case GoParser::IMAGINARY_LIT:
      case GoParser::RUNE_LIT:
      case GoParser::RAW_STRING_LIT:
      case GoParser::INTERPRETED_STRING_LIT: {
        enterOuterAlt(_localctx, 1);
        setState(912);
        expression(0);
        break;
      }

      case GoParser::L_CURLY: {
        enterOuterAlt(_localctx, 2);
        setState(913);
        literalValue();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ElementContext ------------------------------------------------------------------

GoParser::ElementContext::ElementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GoParser::ExpressionContext* GoParser::ElementContext::expression() {
  return getRuleContext<GoParser::ExpressionContext>(0);
}

GoParser::LiteralValueContext* GoParser::ElementContext::literalValue() {
  return getRuleContext<GoParser::LiteralValueContext>(0);
}


size_t GoParser::ElementContext::getRuleIndex() const {
  return GoParser::RuleElement;
}


std::any GoParser::ElementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitElement(this);
  else
    return visitor->visitChildren(this);
}

GoParser::ElementContext* GoParser::element() {
  ElementContext *_localctx = _tracker.createInstance<ElementContext>(_ctx, getState());
  enterRule(_localctx, 182, GoParser::RuleElement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(918);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GoParser::FUNC:
      case GoParser::INTERFACE:
      case GoParser::MAP:
      case GoParser::STRUCT:
      case GoParser::CHAN:
      case GoParser::NIL_LIT:
      case GoParser::IDENTIFIER:
      case GoParser::L_PAREN:
      case GoParser::L_BRACKET:
      case GoParser::EXCLAMATION:
      case GoParser::PLUS:
      case GoParser::MINUS:
      case GoParser::CARET:
      case GoParser::STAR:
      case GoParser::AMPERSAND:
      case GoParser::RECEIVE:
      case GoParser::DECIMAL_LIT:
      case GoParser::BINARY_LIT:
      case GoParser::OCTAL_LIT:
      case GoParser::HEX_LIT:
      case GoParser::FLOAT_LIT:
      case GoParser::IMAGINARY_LIT:
      case GoParser::RUNE_LIT:
      case GoParser::RAW_STRING_LIT:
      case GoParser::INTERPRETED_STRING_LIT: {
        enterOuterAlt(_localctx, 1);
        setState(916);
        expression(0);
        break;
      }

      case GoParser::L_CURLY: {
        enterOuterAlt(_localctx, 2);
        setState(917);
        literalValue();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StructTypeContext ------------------------------------------------------------------

GoParser::StructTypeContext::StructTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GoParser::StructTypeContext::STRUCT() {
  return getToken(GoParser::STRUCT, 0);
}

tree::TerminalNode* GoParser::StructTypeContext::L_CURLY() {
  return getToken(GoParser::L_CURLY, 0);
}

tree::TerminalNode* GoParser::StructTypeContext::R_CURLY() {
  return getToken(GoParser::R_CURLY, 0);
}

std::vector<GoParser::FieldDeclContext *> GoParser::StructTypeContext::fieldDecl() {
  return getRuleContexts<GoParser::FieldDeclContext>();
}

GoParser::FieldDeclContext* GoParser::StructTypeContext::fieldDecl(size_t i) {
  return getRuleContext<GoParser::FieldDeclContext>(i);
}

std::vector<GoParser::EosContext *> GoParser::StructTypeContext::eos() {
  return getRuleContexts<GoParser::EosContext>();
}

GoParser::EosContext* GoParser::StructTypeContext::eos(size_t i) {
  return getRuleContext<GoParser::EosContext>(i);
}


size_t GoParser::StructTypeContext::getRuleIndex() const {
  return GoParser::RuleStructType;
}


std::any GoParser::StructTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitStructType(this);
  else
    return visitor->visitChildren(this);
}

GoParser::StructTypeContext* GoParser::structType() {
  StructTypeContext *_localctx = _tracker.createInstance<StructTypeContext>(_ctx, getState());
  enterRule(_localctx, 184, GoParser::RuleStructType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(920);
    match(GoParser::STRUCT);
    setState(921);
    match(GoParser::L_CURLY);
    setState(927);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == GoParser::IDENTIFIER

    || _la == GoParser::STAR) {
      setState(922);
      fieldDecl();
      setState(923);
      eos();
      setState(929);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(930);
    match(GoParser::R_CURLY);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FieldDeclContext ------------------------------------------------------------------

GoParser::FieldDeclContext::FieldDeclContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GoParser::IdentifierListContext* GoParser::FieldDeclContext::identifierList() {
  return getRuleContext<GoParser::IdentifierListContext>(0);
}

GoParser::Type_Context* GoParser::FieldDeclContext::type_() {
  return getRuleContext<GoParser::Type_Context>(0);
}

GoParser::EmbeddedFieldContext* GoParser::FieldDeclContext::embeddedField() {
  return getRuleContext<GoParser::EmbeddedFieldContext>(0);
}

GoParser::String_Context* GoParser::FieldDeclContext::string_() {
  return getRuleContext<GoParser::String_Context>(0);
}


size_t GoParser::FieldDeclContext::getRuleIndex() const {
  return GoParser::RuleFieldDecl;
}


std::any GoParser::FieldDeclContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitFieldDecl(this);
  else
    return visitor->visitChildren(this);
}

GoParser::FieldDeclContext* GoParser::fieldDecl() {
  FieldDeclContext *_localctx = _tracker.createInstance<FieldDeclContext>(_ctx, getState());
  enterRule(_localctx, 186, GoParser::RuleFieldDecl);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(936);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 106, _ctx)) {
    case 1: {
      setState(932);
      identifierList();
      setState(933);
      type_();
      break;
    }

    case 2: {
      setState(935);
      embeddedField();
      break;
    }

    default:
      break;
    }
    setState(939);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 107, _ctx)) {
    case 1: {
      setState(938);
      antlrcpp::downCast<FieldDeclContext *>(_localctx)->tag = string_();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- String_Context ------------------------------------------------------------------

GoParser::String_Context::String_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GoParser::String_Context::RAW_STRING_LIT() {
  return getToken(GoParser::RAW_STRING_LIT, 0);
}

tree::TerminalNode* GoParser::String_Context::INTERPRETED_STRING_LIT() {
  return getToken(GoParser::INTERPRETED_STRING_LIT, 0);
}


size_t GoParser::String_Context::getRuleIndex() const {
  return GoParser::RuleString_;
}


std::any GoParser::String_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitString_(this);
  else
    return visitor->visitChildren(this);
}

GoParser::String_Context* GoParser::string_() {
  String_Context *_localctx = _tracker.createInstance<String_Context>(_ctx, getState());
  enterRule(_localctx, 188, GoParser::RuleString_);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(941);
    _la = _input->LA(1);
    if (!(_la == GoParser::RAW_STRING_LIT

    || _la == GoParser::INTERPRETED_STRING_LIT)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EmbeddedFieldContext ------------------------------------------------------------------

GoParser::EmbeddedFieldContext::EmbeddedFieldContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GoParser::TypeNameContext* GoParser::EmbeddedFieldContext::typeName() {
  return getRuleContext<GoParser::TypeNameContext>(0);
}

tree::TerminalNode* GoParser::EmbeddedFieldContext::STAR() {
  return getToken(GoParser::STAR, 0);
}

GoParser::TypeArgsContext* GoParser::EmbeddedFieldContext::typeArgs() {
  return getRuleContext<GoParser::TypeArgsContext>(0);
}


size_t GoParser::EmbeddedFieldContext::getRuleIndex() const {
  return GoParser::RuleEmbeddedField;
}


std::any GoParser::EmbeddedFieldContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitEmbeddedField(this);
  else
    return visitor->visitChildren(this);
}

GoParser::EmbeddedFieldContext* GoParser::embeddedField() {
  EmbeddedFieldContext *_localctx = _tracker.createInstance<EmbeddedFieldContext>(_ctx, getState());
  enterRule(_localctx, 190, GoParser::RuleEmbeddedField);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(944);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GoParser::STAR) {
      setState(943);
      match(GoParser::STAR);
    }
    setState(946);
    typeName();
    setState(948);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 109, _ctx)) {
    case 1: {
      setState(947);
      typeArgs();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionLitContext ------------------------------------------------------------------

GoParser::FunctionLitContext::FunctionLitContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GoParser::FunctionLitContext::FUNC() {
  return getToken(GoParser::FUNC, 0);
}

GoParser::SignatureContext* GoParser::FunctionLitContext::signature() {
  return getRuleContext<GoParser::SignatureContext>(0);
}

GoParser::BlockContext* GoParser::FunctionLitContext::block() {
  return getRuleContext<GoParser::BlockContext>(0);
}


size_t GoParser::FunctionLitContext::getRuleIndex() const {
  return GoParser::RuleFunctionLit;
}


std::any GoParser::FunctionLitContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitFunctionLit(this);
  else
    return visitor->visitChildren(this);
}

GoParser::FunctionLitContext* GoParser::functionLit() {
  FunctionLitContext *_localctx = _tracker.createInstance<FunctionLitContext>(_ctx, getState());
  enterRule(_localctx, 192, GoParser::RuleFunctionLit);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(950);
    match(GoParser::FUNC);
    setState(951);
    signature();
    setState(952);
    block();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IndexContext ------------------------------------------------------------------

GoParser::IndexContext::IndexContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GoParser::IndexContext::L_BRACKET() {
  return getToken(GoParser::L_BRACKET, 0);
}

GoParser::ExpressionContext* GoParser::IndexContext::expression() {
  return getRuleContext<GoParser::ExpressionContext>(0);
}

tree::TerminalNode* GoParser::IndexContext::R_BRACKET() {
  return getToken(GoParser::R_BRACKET, 0);
}


size_t GoParser::IndexContext::getRuleIndex() const {
  return GoParser::RuleIndex;
}


std::any GoParser::IndexContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitIndex(this);
  else
    return visitor->visitChildren(this);
}

GoParser::IndexContext* GoParser::index() {
  IndexContext *_localctx = _tracker.createInstance<IndexContext>(_ctx, getState());
  enterRule(_localctx, 194, GoParser::RuleIndex);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(954);
    match(GoParser::L_BRACKET);
    setState(955);
    expression(0);
    setState(956);
    match(GoParser::R_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Slice_Context ------------------------------------------------------------------

GoParser::Slice_Context::Slice_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GoParser::Slice_Context::L_BRACKET() {
  return getToken(GoParser::L_BRACKET, 0);
}

tree::TerminalNode* GoParser::Slice_Context::R_BRACKET() {
  return getToken(GoParser::R_BRACKET, 0);
}

std::vector<tree::TerminalNode *> GoParser::Slice_Context::COLON() {
  return getTokens(GoParser::COLON);
}

tree::TerminalNode* GoParser::Slice_Context::COLON(size_t i) {
  return getToken(GoParser::COLON, i);
}

std::vector<GoParser::ExpressionContext *> GoParser::Slice_Context::expression() {
  return getRuleContexts<GoParser::ExpressionContext>();
}

GoParser::ExpressionContext* GoParser::Slice_Context::expression(size_t i) {
  return getRuleContext<GoParser::ExpressionContext>(i);
}


size_t GoParser::Slice_Context::getRuleIndex() const {
  return GoParser::RuleSlice_;
}


std::any GoParser::Slice_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitSlice_(this);
  else
    return visitor->visitChildren(this);
}

GoParser::Slice_Context* GoParser::slice_() {
  Slice_Context *_localctx = _tracker.createInstance<Slice_Context>(_ctx, getState());
  enterRule(_localctx, 196, GoParser::RuleSlice_);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(958);
    match(GoParser::L_BRACKET);
    setState(974);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 113, _ctx)) {
    case 1: {
      setState(960);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & -288230371386978792) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & 99135) != 0)) {
        setState(959);
        expression(0);
      }
      setState(962);
      match(GoParser::COLON);
      setState(964);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & -288230371386978792) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & 99135) != 0)) {
        setState(963);
        expression(0);
      }
      break;
    }

    case 2: {
      setState(967);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & -288230371386978792) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & 99135) != 0)) {
        setState(966);
        expression(0);
      }
      setState(969);
      match(GoParser::COLON);
      setState(970);
      expression(0);
      setState(971);
      match(GoParser::COLON);
      setState(972);
      expression(0);
      break;
    }

    default:
      break;
    }
    setState(976);
    match(GoParser::R_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeAssertionContext ------------------------------------------------------------------

GoParser::TypeAssertionContext::TypeAssertionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GoParser::TypeAssertionContext::DOT() {
  return getToken(GoParser::DOT, 0);
}

tree::TerminalNode* GoParser::TypeAssertionContext::L_PAREN() {
  return getToken(GoParser::L_PAREN, 0);
}

GoParser::Type_Context* GoParser::TypeAssertionContext::type_() {
  return getRuleContext<GoParser::Type_Context>(0);
}

tree::TerminalNode* GoParser::TypeAssertionContext::R_PAREN() {
  return getToken(GoParser::R_PAREN, 0);
}


size_t GoParser::TypeAssertionContext::getRuleIndex() const {
  return GoParser::RuleTypeAssertion;
}


std::any GoParser::TypeAssertionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitTypeAssertion(this);
  else
    return visitor->visitChildren(this);
}

GoParser::TypeAssertionContext* GoParser::typeAssertion() {
  TypeAssertionContext *_localctx = _tracker.createInstance<TypeAssertionContext>(_ctx, getState());
  enterRule(_localctx, 198, GoParser::RuleTypeAssertion);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(978);
    match(GoParser::DOT);
    setState(979);
    match(GoParser::L_PAREN);
    setState(980);
    type_();
    setState(981);
    match(GoParser::R_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArgumentsContext ------------------------------------------------------------------

GoParser::ArgumentsContext::ArgumentsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GoParser::ArgumentsContext::L_PAREN() {
  return getToken(GoParser::L_PAREN, 0);
}

tree::TerminalNode* GoParser::ArgumentsContext::R_PAREN() {
  return getToken(GoParser::R_PAREN, 0);
}

GoParser::ExpressionListContext* GoParser::ArgumentsContext::expressionList() {
  return getRuleContext<GoParser::ExpressionListContext>(0);
}

GoParser::Type_Context* GoParser::ArgumentsContext::type_() {
  return getRuleContext<GoParser::Type_Context>(0);
}

tree::TerminalNode* GoParser::ArgumentsContext::ELLIPSIS() {
  return getToken(GoParser::ELLIPSIS, 0);
}

std::vector<tree::TerminalNode *> GoParser::ArgumentsContext::COMMA() {
  return getTokens(GoParser::COMMA);
}

tree::TerminalNode* GoParser::ArgumentsContext::COMMA(size_t i) {
  return getToken(GoParser::COMMA, i);
}


size_t GoParser::ArgumentsContext::getRuleIndex() const {
  return GoParser::RuleArguments;
}


std::any GoParser::ArgumentsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitArguments(this);
  else
    return visitor->visitChildren(this);
}

GoParser::ArgumentsContext* GoParser::arguments() {
  ArgumentsContext *_localctx = _tracker.createInstance<ArgumentsContext>(_ctx, getState());
  enterRule(_localctx, 200, GoParser::RuleArguments);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(983);
    match(GoParser::L_PAREN);
    setState(998);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -288230371386978792) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 99135) != 0)) {
      setState(990);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 115, _ctx)) {
      case 1: {
        setState(984);
        expressionList();
        break;
      }

      case 2: {
        setState(985);
        type_();
        setState(988);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 114, _ctx)) {
        case 1: {
          setState(986);
          match(GoParser::COMMA);
          setState(987);
          expressionList();
          break;
        }

        default:
          break;
        }
        break;
      }

      default:
        break;
      }
      setState(993);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GoParser::ELLIPSIS) {
        setState(992);
        match(GoParser::ELLIPSIS);
      }
      setState(996);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GoParser::COMMA) {
        setState(995);
        match(GoParser::COMMA);
      }
    }
    setState(1000);
    match(GoParser::R_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MethodExprContext ------------------------------------------------------------------

GoParser::MethodExprContext::MethodExprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GoParser::Type_Context* GoParser::MethodExprContext::type_() {
  return getRuleContext<GoParser::Type_Context>(0);
}

tree::TerminalNode* GoParser::MethodExprContext::DOT() {
  return getToken(GoParser::DOT, 0);
}

tree::TerminalNode* GoParser::MethodExprContext::IDENTIFIER() {
  return getToken(GoParser::IDENTIFIER, 0);
}


size_t GoParser::MethodExprContext::getRuleIndex() const {
  return GoParser::RuleMethodExpr;
}


std::any GoParser::MethodExprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitMethodExpr(this);
  else
    return visitor->visitChildren(this);
}

GoParser::MethodExprContext* GoParser::methodExpr() {
  MethodExprContext *_localctx = _tracker.createInstance<MethodExprContext>(_ctx, getState());
  enterRule(_localctx, 202, GoParser::RuleMethodExpr);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1002);
    type_();
    setState(1003);
    match(GoParser::DOT);
    setState(1004);
    match(GoParser::IDENTIFIER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EosContext ------------------------------------------------------------------

GoParser::EosContext::EosContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GoParser::EosContext::SEMI() {
  return getToken(GoParser::SEMI, 0);
}

tree::TerminalNode* GoParser::EosContext::EOF() {
  return getToken(GoParser::EOF, 0);
}

tree::TerminalNode* GoParser::EosContext::EOS() {
  return getToken(GoParser::EOS, 0);
}


size_t GoParser::EosContext::getRuleIndex() const {
  return GoParser::RuleEos;
}


std::any GoParser::EosContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<GoParserVisitor*>(visitor))
    return parserVisitor->visitEos(this);
  else
    return visitor->visitChildren(this);
}

GoParser::EosContext* GoParser::eos() {
  EosContext *_localctx = _tracker.createInstance<EosContext>(_ctx, getState());
  enterRule(_localctx, 204, GoParser::RuleEos);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1010);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 119, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1006);
      match(GoParser::SEMI);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1007);
      match(GoParser::EOF);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1008);
      match(GoParser::EOS);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1009);

      if (!(this->closingBracket())) throw FailedPredicateException(this, "this->closingBracket()");
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

bool GoParser::sempred(RuleContext *context, size_t ruleIndex, size_t predicateIndex) {
  switch (ruleIndex) {
    case 24: return statementListSempred(antlrcpp::downCast<StatementListContext *>(context), predicateIndex);
    case 76: return expressionSempred(antlrcpp::downCast<ExpressionContext *>(context), predicateIndex);
    case 77: return primaryExprSempred(antlrcpp::downCast<PrimaryExprContext *>(context), predicateIndex);
    case 102: return eosSempred(antlrcpp::downCast<EosContext *>(context), predicateIndex);

  default:
    break;
  }
  return true;
}

bool GoParser::statementListSempred(StatementListContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 0: return this->closingBracket();

  default:
    break;
  }
  return true;
}

bool GoParser::expressionSempred(ExpressionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 1: return precpred(_ctx, 5);
    case 2: return precpred(_ctx, 4);
    case 3: return precpred(_ctx, 3);
    case 4: return precpred(_ctx, 2);
    case 5: return precpred(_ctx, 1);

  default:
    break;
  }
  return true;
}

bool GoParser::primaryExprSempred(PrimaryExprContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 6: return precpred(_ctx, 1);

  default:
    break;
  }
  return true;
}

bool GoParser::eosSempred(EosContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 7: return this->closingBracket();

  default:
    break;
  }
  return true;
}

void GoParser::initialize() {
#if ANTLR4_USE_THREAD_LOCAL_CACHE
  goparserParserInitialize();
#else
  ::antlr4::internal::call_once(goparserParserOnceFlag, goparserParserInitialize);
#endif
}
